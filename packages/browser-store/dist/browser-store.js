/******/ (function(modules) { // webpackBootstrap
/******/ 	// install a JSONP callback for chunk loading
/******/ 	function webpackJsonpCallback(data) {
/******/ 		var chunkIds = data[0];
/******/ 		var moreModules = data[1];
/******/
/******/
/******/ 		// add "moreModules" to the modules object,
/******/ 		// then flag all "chunkIds" as loaded and fire callback
/******/ 		var moduleId, chunkId, i = 0, resolves = [];
/******/ 		for(;i < chunkIds.length; i++) {
/******/ 			chunkId = chunkIds[i];
/******/ 			if(Object.prototype.hasOwnProperty.call(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 				resolves.push(installedChunks[chunkId][0]);
/******/ 			}
/******/ 			installedChunks[chunkId] = 0;
/******/ 		}
/******/ 		for(moduleId in moreModules) {
/******/ 			if(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {
/******/ 				modules[moduleId] = moreModules[moduleId];
/******/ 			}
/******/ 		}
/******/ 		if(parentJsonpFunction) parentJsonpFunction(data);
/******/
/******/ 		while(resolves.length) {
/******/ 			resolves.shift()();
/******/ 		}
/******/
/******/ 	};
/******/
/******/
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// object to store loaded and loading chunks
/******/ 	// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 	// Promise = chunk loading, 0 = chunk loaded
/******/ 	var installedChunks = {
/******/ 		"browser-store": 0
/******/ 	};
/******/
/******/
/******/
/******/ 	// script path function
/******/ 	function jsonpScriptSrc(chunkId) {
/******/ 		return __webpack_require__.p + "" + ({"swan_modules/date":"swan_modules/date","swan_modules/debug":"swan_modules/debug","swan_modules/http":"swan_modules/http","swan_modules/json":"swan_modules/json","swan_modules/list":"swan_modules/list","swan_modules/math":"swan_modules/math","swan_modules/path":"swan_modules/path","swan_modules/text":"swan_modules/text","vendors~swan_modules/markdown":"vendors~swan_modules/markdown"}[chunkId]||chunkId) + ".js"
/******/ 	}
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/ 	// This file contains only the entry chunk.
/******/ 	// The chunk loading function for additional chunks
/******/ 	__webpack_require__.e = function requireEnsure(chunkId) {
/******/ 		var promises = [];
/******/
/******/
/******/ 		// JSONP chunk loading for javascript
/******/
/******/ 		var installedChunkData = installedChunks[chunkId];
/******/ 		if(installedChunkData !== 0) { // 0 means "already installed".
/******/
/******/ 			// a Promise means "currently loading".
/******/ 			if(installedChunkData) {
/******/ 				promises.push(installedChunkData[2]);
/******/ 			} else {
/******/ 				// setup Promise in chunk cache
/******/ 				var promise = new Promise(function(resolve, reject) {
/******/ 					installedChunkData = installedChunks[chunkId] = [resolve, reject];
/******/ 				});
/******/ 				promises.push(installedChunkData[2] = promise);
/******/
/******/ 				// start chunk loading
/******/ 				var script = document.createElement('script');
/******/ 				var onScriptComplete;
/******/
/******/ 				script.charset = 'utf-8';
/******/ 				script.timeout = 120;
/******/ 				if (__webpack_require__.nc) {
/******/ 					script.setAttribute("nonce", __webpack_require__.nc);
/******/ 				}
/******/ 				script.src = jsonpScriptSrc(chunkId);
/******/
/******/ 				// create error before stack unwound to get useful stacktrace later
/******/ 				var error = new Error();
/******/ 				onScriptComplete = function (event) {
/******/ 					// avoid mem leaks in IE.
/******/ 					script.onerror = script.onload = null;
/******/ 					clearTimeout(timeout);
/******/ 					var chunk = installedChunks[chunkId];
/******/ 					if(chunk !== 0) {
/******/ 						if(chunk) {
/******/ 							var errorType = event && (event.type === 'load' ? 'missing' : event.type);
/******/ 							var realSrc = event && event.target && event.target.src;
/******/ 							error.message = 'Loading chunk ' + chunkId + ' failed.\n(' + errorType + ': ' + realSrc + ')';
/******/ 							error.name = 'ChunkLoadError';
/******/ 							error.type = errorType;
/******/ 							error.request = realSrc;
/******/ 							chunk[1](error);
/******/ 						}
/******/ 						installedChunks[chunkId] = undefined;
/******/ 					}
/******/ 				};
/******/ 				var timeout = setTimeout(function(){
/******/ 					onScriptComplete({ type: 'timeout', target: script });
/******/ 				}, 120000);
/******/ 				script.onerror = script.onload = onScriptComplete;
/******/ 				document.head.appendChild(script);
/******/ 			}
/******/ 		}
/******/ 		return Promise.all(promises);
/******/ 	};
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// on error function for async loading
/******/ 	__webpack_require__.oe = function(err) { console.error(err); throw err; };
/******/
/******/ 	var jsonpArray = window["webpackJsonp"] = window["webpackJsonp"] || [];
/******/ 	var oldJsonpFunction = jsonpArray.push.bind(jsonpArray);
/******/ 	jsonpArray.push = webpackJsonpCallback;
/******/ 	jsonpArray = jsonpArray.slice();
/******/ 	for(var i = 0; i < jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]);
/******/ 	var parentJsonpFunction = oldJsonpFunction;
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./index.js":
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const olojs = __webpack_require__(/*! @onlabsorg/olojs/browser */ \"./node_modules/@onlabsorg/olojs/browser.js\");\nconst localForage = __webpack_require__(/*! localforage */ \"./node_modules/localforage/dist/localforage.js\");\n\n\nclass BrowserStore extends olojs.Store {\n    \n    constructor (storeId) {\n        super();\n        this._backend = localForage.createInstance({\n            name: 'storeId',\n            version: 0.1\n        });\n    }\n    \n    async read (path) {\n        const key = this.normalizePath(path);\n        const value = await this._backend.getItem(key);\n        return value === null ? \"\" : String(value);\n    }\n    \n    async list (path) {\n        const normPath = this.normalizePath(`${path}/`);\n        const items = [];\n        for (let i=0; i < await this._backend.length(); i++) {\n            const key = await this._backend.key(i);\n            if (key.indexOf(normPath) === 0) {\n                const subPath = key.slice(normPath.length);\n                const slashIndex = subPath.indexOf('/');\n                const item = slashIndex === -1 ? subPath : subPath.slice(0, slashIndex+1);\n                if (items.indexOf(item) === -1) items.push(item);\n            }\n        }\n        return items;\n    }\n    \n    async write (path, source) {\n        const key = this.normalizePath(path);\n        const value = String(source);\n        await this._backend.setItem(key, value);\n    }\n    \n    async delete (path) {\n        const key = this.normalizePath(path);\n        await this._backend.removeItem(key);\n    }\n    \n    async deleteAll (path) {\n        const normPath = this.normalizePath(`${path}/`);\n        const docPaths = [];\n        for (let i=0; i < (await this._backend.length()); i++) {\n            docPaths.push(await this._backend.key(i));\n        }        \n        for (let docPath of docPaths) {\n            if (docPath.indexOf(normPath) === 0) {\n                await this.delete(docPath);\n            }\n        }\n    }\n}\n\nolojs.BrowserStore = BrowserStore;\n\n\n//# sourceURL=webpack:///./index.js?");

/***/ }),

/***/ "./node_modules/@onlabsorg/olojs/browser.js":
/*!**************************************************!*\
  !*** ./node_modules/@onlabsorg/olojs/browser.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\nconst olojs = window.olojs = module.exports = {};\n\nolojs.expression  = __webpack_require__(/*! ./lib/expression */ \"./node_modules/@onlabsorg/olojs/lib/expression.js\");\nolojs.document    = __webpack_require__(/*! ./lib/document */ \"./node_modules/@onlabsorg/olojs/lib/document.js\");\n\nolojs.Store       = __webpack_require__(/*! ./lib/store */ \"./node_modules/@onlabsorg/olojs/lib/store.js\");\nolojs.MemoryStore = __webpack_require__(/*! ./lib/memory-store */ \"./node_modules/@onlabsorg/olojs/lib/memory-store.js\");\nolojs.HTTPStore   = __webpack_require__(/*! ./lib/http-store */ \"./node_modules/@onlabsorg/olojs/lib/http-store.js\");\nolojs.Router      = __webpack_require__(/*! ./lib/router */ \"./node_modules/@onlabsorg/olojs/lib/router.js\");\n\nolojs.Viewer      = __webpack_require__(/*! ./lib/viewer */ \"./node_modules/@onlabsorg/olojs/lib/viewer.js\");\n\n\n//# sourceURL=webpack:///./node_modules/@onlabsorg/olojs/browser.js?");

/***/ }),

/***/ "./node_modules/@onlabsorg/olojs/lib/document.js":
/*!*******************************************************!*\
  !*** ./node_modules/@onlabsorg/olojs/lib/document.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n *  olojs.document\n *  ============================================================================\n *  This module contains functions to parse, evaluate and render olojs\n *  documents.\n *\n *  ```js\n *  source = \"Twice x is <% 2*x %>!\";\n *  evaluate = olojs.document.parse(source);\n *  context = olojs.document.createContext({x:10});\n *  namespace = await evaluate(context);    // {x:10}\n *  text = await context.str(namespace);    // \"Twice x is 20\"\n *  ```\n */\n\nconst swan = __webpack_require__(/*! ./expression */ \"./node_modules/@onlabsorg/olojs/lib/expression.js\");\n\n\n\n/**\n *  olojs.document.parse - function\n *  ----------------------------------------------------------------------------\n *  Compiles a document source into an `evaluate` function that takes as input\n *  a document context object and returns the document namespace object.\n *\n *  ```js\n *  evaluate = olojs.document.parse(source);\n *  namespace = await evaluate(context);\n *  ```\n *\n *  - `source` is a string containing the source of an olojs document\n *  - `evaluate` is an asynchronous function that evaluates the document and\n *    returns its namespace\n *  - `namespace` is an object containing all the names defined by the inline\n *    expressions of the document.\n *\n *  The document namespace stringifies to a text obtained by replacing every\n *  inline expression with its value, therefore in javascript\n *  `await context.str(namespace)` will return the rendered document.\n */\nconst parseDocument = exports.parse = function (source) {\n    source = String(source);\n\n    // // Parse fragments\n    // source = source.replace(/<\\s*def:([a-z_A-Z]+[a-z_A-Z0-9]*)\\s+(.*)>(.*)<\\s*\\/def:\\1\\s*>/g, (match, identifier, attributes, content) => {\n    //     return \"\";\n    // });    \n\n    // Find all the swan expressions in the source, store them in an array and\n    // replace them with a placeholder.\n    const parsedExpressions = [];\n    source = source.replace(/<%([\\s\\S]+?)%>/g, (match, expressionSource) => {\n        let i = parsedExpressions.length;\n        let parsedExpression = swan.parse(expressionSource);\n        parsedExpression.source = expressionSource;\n        parsedExpressions.push( parsedExpression );\n        return `<%%>`;\n    });\n    const textChunks = source.split('<%%>');\n    const $text = Symbol(\"Rendered document\");\n\n    // The returned `evaluate` function\n    return async (context) => {\n        // Create a copy ot the context\n        context = Object.assign(Object.create(Object.getPrototypeOf(context)), context);\n        \n        // Evaluate each expression in the given context and replace the\n        // expression source with the stringified expression value\n        context.__str__ = textChunks[0] || \"\";\n        for (let i=0; i<parsedExpressions.length; i++) {\n            let evaluateExpression = parsedExpressions[i];\n            try {\n                var value = await evaluateExpression(context);\n            } catch (error) {\n                // in case of error returns an Undefined failure value\n                var value = await context.undefined('failure', error);\n            }\n            context.__str__ += await context.str(value) + textChunks[i+1];\n        }\n        \n        // Extract the document namespace,\n        // discarding the global context variables.\n        return Object.assign({}, context);\n    };\n}\n\n\n\n\n/**\n *  olojs.document.createContext - function\n *  ----------------------------------------------------------------------------\n *  Creates a custom document evaluation context, by adding to the basic\n *  context all the names defined in the passed namespace.\n *\n *  ```js\n *  context = olojs.document.createContext(...namespaces)\n *  ```\n *  - `namespaces`: list of objects; each of them, from left to right, will be\n *    mixed-in to the basic document context\n *  - `context`: an object containing all the named values and functions that\n *    will be visible to the document inline expressions.\n */\nexports.createContext = function (...namespaces) {\n    return swan.createContext(documentGlobals, ...namespaces);\n}\n\nconst documentGlobals = {};\n\n\n//# sourceURL=webpack:///./node_modules/@onlabsorg/olojs/lib/document.js?");

/***/ }),

/***/ "./node_modules/@onlabsorg/olojs/lib/expression.js":
/*!*********************************************************!*\
  !*** ./node_modules/@onlabsorg/olojs/lib/expression.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const swan = __webpack_require__(/*! @onlabsorg/swan-js */ \"./node_modules/@onlabsorg/swan-js/index.js\");\n\nconst Lexer = __webpack_require__(/*! @onlabsorg/swan-js/lib/lexer */ \"./node_modules/@onlabsorg/swan-js/lib/lexer.js\");\nLexer.matchIdentifier = identifier => /^[a-z_A-Z]+[a-z_A-Z0-9]*$/.test(identifier);\n\nswan.defineModule(\"markdown\" , () => __webpack_require__.e(/*! import() | swan_modules/markdown */ \"vendors~swan_modules/markdown\").then(__webpack_require__.t.bind(null, /*! ./swan_modules/markdown.js */ \"./node_modules/@onlabsorg/olojs/lib/swan_modules/markdown.js\", 7)));\n\nmodule.exports = swan;\n\n\n//# sourceURL=webpack:///./node_modules/@onlabsorg/olojs/lib/expression.js?");

/***/ }),

/***/ "./node_modules/@onlabsorg/olojs/lib/http-store.js":
/*!*********************************************************!*\
  !*** ./node_modules/@onlabsorg/olojs/lib/http-store.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("__webpack_require__(/*! isomorphic-fetch */ \"./node_modules/isomorphic-fetch/fetch-npm-browserify.js\");\nconst pathlib = __webpack_require__(/*! path */ \"./node_modules/node-libs-browser/node_modules/path-browserify/index.js\");\nconst Store = __webpack_require__(/*! ./store */ \"./node_modules/@onlabsorg/olojs/lib/store.js\");\n\n\nconst isObject = obj => obj && typeof obj === 'object' && !Array.isArray(obj);\n\n\n/**\n *  HTTPStore\n *  ============================================================================\n *  This store handles read/write operations on remote olo-documents\n *  via HTTP(S).\n *  \n *  ```js\n *  httpStore = new HTTPStore(rootURL, options)\n *  ```\n *  \n *  - `rootURL` is the base URL that will be prepended to the paths passed to\n *    the `read`, `list`, `write` and `delete` methods.\n *  - `options.headers` are custom headers that will be added to every HTTP\n *    request.\n *  - `httpStore` is a [olojs.Store](./store.md) object\n */\nclass HTTPStore extends Store {\n\n    constructor (rootURL, options={}) {\n        super();\n        if (rootURL.slice(0,6).toLowerCase() === 'http:/') {\n            this.rootURL = 'http:/' + pathlib.normalize(`/${rootURL.slice(6)}/`);\n        } else if (rootURL.slice(0,7).toLowerCase() === 'https:/') {\n            this.rootURL = 'https:/' + pathlib.normalize(`/${rootURL.slice(7)}/`);\n        } else {\n            throw new Error(`Invalid http URL: ${rootURL}`)\n        }\n        this.headers = isObject(options.headers) ? options.headers : {};\n    }\n\n    resolveURL (path) {\n        return this.rootURL + pathlib.normalize(`/${path}`).slice(1);\n    }\n\n\n    /**\n     *  httpStore.read - async method\n     *  ------------------------------------------------------------------------\n     *  Retrieves a remote olo-document via HTTP GET (HTTPS GET).\n     *  \n     *  ```js\n     *  source = await httpStore.read(\"/path/to/doc\")\n     *  ```\n     *  \n     *  - On 200 status code, returns the response body as string\n     *  - On 403 status code, throws a `HTTPStore.ReadPermissionDeniedError`\n     *  - On 404 status code, return an empty string\n     *  - On 405 status code, throws a `HTTPStore.ReadOperationNotAllowedError`\n     *  - On any other status code, throws a generic error\n     */\n    async read (path) {\n        const url = this.resolveURL(path);\n\n        const response = await fetch(url, {\n            method: 'get',\n            headers: Object.assign({}, this.headers, {\n                'Accept': 'text/*',\n            }),\n        });\n\n        switch (response.status) {\n            case 200:\n                return await response.text();\n            case 403:\n                throw new this.constructor.ReadPermissionDeniedError(url);\n            case 404:\n                return \"\";\n            case 405:\n                throw new this.constructor.ReadOperationNotAllowedError(url);\n            default:\n                let message = await response.text();\n                throw new Error(message);\n        }\n    }\n\n\n    /**\n     *  httpStore.list - async method\n     *  ------------------------------------------------------------------------\n     *  Retrieves a remote directory content via an HTTP GET requests that\n     *  accepts only JSON as response.\n     *  \n     *  ```js\n     *  entries = await httpStore.list(\"/path/to/doc\")\n     *  ```\n     *  \n     *  - On 200 status code, returns the response body as json array\n     *  - On 403 status code, throws a `HTTPStore.ReadPermissionDeniedError`\n     *  - On 404 status code, return an empty array\n     *  - On 405 status code, throws a `HTTPStore.ReadOperationNotAllowedError`\n     *  - On any other status code, throws a generic error\n     */\n    async list (path) {\n        const url = this.resolveURL(path);\n\n        const response = await fetch(url, {\n            method: 'get',\n            headers: Object.assign({}, this.headers, {\n                'Accept': 'application/json',\n            }),\n        });\n\n        switch (response.status) {\n            case 200:\n                const entries = await response.json();\n                if (!Array.isArray(entries)) throw new Error('Array json response expected');\n                return entries;\n            case 403:\n                throw new this.constructor.ReadPermissionDeniedError(url);\n            case 404:\n                return [];\n            case 405:\n                throw new this.constructor.ReadOperationNotAllowedError(url);\n            default:\n                let message = await response.text();\n                throw new Error(message);\n        }\n    }\n\n\n    /**\n     *  httpStore.write - async method\n     *  ------------------------------------------------------------------------\n     *  Modifies a remote olo-document via HTTP PUT (HTTPS PUT).\n     *  \n     *  ```js\n     *  await httpStore.write(\"/path/to/doc\", source)\n     *  ```\n     *  \n     *  - On 200 and 201 status code, returns\n     *  - On 403 status code, throws a `HTTPStore.WritePermissionDeniedError`\n     *  - On 405 status code, throws a `HTTPStore.WriteOperationNotAllowedError`\n     *  - On any other status code, throws a generic error\n     */\n    async write (path, source) {\n        const url = this.resolveURL(path);\n\n        const response = await fetch(url, {\n            method: 'put',\n            headers: Object.assign({}, this.headers, {\n                'Accept': 'text/*',\n                'Content-Type': 'text/plain',\n            }),\n            body: String(source)\n        });\n\n        switch (response.status) {\n            case 200:\n            case 201:\n                break;\n            case 403:\n                throw new this.constructor.WritePermissionDeniedError(url);\n            case 405:\n                throw new this.constructor.WriteOperationNotAllowedError(url);\n            default:\n                let message = await response.text();\n                throw new Error(message);\n        }\n    }\n\n\n    /**\n     *  httpStore.delete - async method\n     *  ------------------------------------------------------------------------\n     *  Modifies a remote olo-document via HTTP DELETE (HTTPS DELETE).\n     *  \n     *  ```js\n     *  await httpStore.delete(\"/path/to/doc\")\n     *  ```\n     *  \n     *  - On 200 status code, returns\n     *  - On 403 status code, throws a `HTTPStore.WritePermissionDeniedError`\n     *  - On 405 status code, throws a `HTTPStore.WriteOperationNotAllowedError`\n     *  - On any other status code, throws a generic error\n     */\n    async delete (path) {\n        const url = this.resolveURL(path);\n\n        const response = await fetch(url, {\n            method: 'delete',\n            headers: Object.assign({}, this.headers, {\n                'Accept': 'text/*',\n                'Content-Type': 'text/plain',\n            })\n        });\n\n        switch (response.status) {\n            case 200:\n                break;\n            case 403:\n                throw new this.constructor.WritePermissionDeniedError(url);\n            case 405:\n                throw new this.constructor.WriteOperationNotAllowedError(url);\n            default:\n                let message = await response.text();\n                throw new Error(message);\n        }\n    }\n\n\n    /**\n     *  httpStore.deleteAll - async method\n     *  ------------------------------------------------------------------------\n     *  Modifies a remote `text/direcotry` resource via HTTP DELETE (HTTPS DELETE)\n     *  that accepts `text/directory` as MimeType.\n     *  \n     *  ```js\n     *  await httpStore.deleteAll(\"/path/to/dir\")\n     *  ```\n     *  \n     *  - On 200 status code, returns\n     *  - On 403 status code, throws a `HTTPStore.WritePermissionDeniedError`\n     *  - On 405 status code, throws a `HTTPStore.WriteOperationNotAllowedError`\n     *  - On any other status code, throws a generic error\n     */\n    async deleteAll (path) {\n        const url = this.resolveURL(path);\n\n        const response = await fetch(url, {\n            method: 'delete',\n            headers: Object.assign({}, this.headers, {\n                'Accept': 'text/*',\n                'Content-Type': 'text/directory',\n            })\n        });\n\n        switch (response.status) {\n            case 200:\n                break;\n            case 403:\n                throw new this.constructor.WritePermissionDeniedError(url);\n            case 405:\n                throw new this.constructor.WriteOperationNotAllowedError(url);\n            default:\n                let message = await response.text();\n                throw new Error(message);\n        }\n    }\n}\n\n\nmodule.exports = HTTPStore;\n\n\n//# sourceURL=webpack:///./node_modules/@onlabsorg/olojs/lib/http-store.js?");

/***/ }),

/***/ "./node_modules/@onlabsorg/olojs/lib/memory-store.js":
/*!***********************************************************!*\
  !*** ./node_modules/@onlabsorg/olojs/lib/memory-store.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const pathlib = __webpack_require__(/*! path */ \"./node_modules/node-libs-browser/node_modules/path-browserify/index.js\");\nconst Store = __webpack_require__(/*! ./store */ \"./node_modules/@onlabsorg/olojs/lib/store.js\");\n\n\n\n/**\n *  MemoryStore\n *  ============================================================================\n *  This store handles read/write operations on an in-memory map object.\n *\n *  ```js\n *  memStore = new MemoryStore(documents)\n *  ```\n *\n *  Where `documents` is an optional object containing path-document pairs that\n *  will be added to the store upon creation.\n *  \n *  The MemoryStore inherits the `load` method and the Error static properties\n *  from the parent `Store` class.\n */\nclass MemoryStore extends Store {\n\n    constructor (documents={}) {\n        super();\n        this._content = new Map();\n        for (let path in documents) {\n            this._content.set(this.normalizePath(path), String(documents[path]));\n        }\n    }\n\n    /**\n     *  memStore.read - method\n     *  ------------------------------------------------------------------------\n     *  Retrieves the in-memory document source mapped to the given path.\n     *\n     *  ```js\n     *  const source = await memStore.read(\"/path/to/doc\");\n     *  ```\n     *  \n     *  - When requesting `path/to/x/../doc`, the content of `/path/to/doc` will\n     *    be returned\n     *  - When requesting an entry that doesn't exist, and empty string will be\n     *    returned\n     */\n    read (path) {\n        const normPath = this.normalizePath(path);\n        return this._content.get(normPath) || \"\";\n    }\n\n\n    /**\n     *  memStore.list - method\n     *  ------------------------------------------------------------------------\n     *  Returns the list of the children of a path.\n     *\n     *  ```\n     *  entries = await memStore.list('/path/to/dir/');\n     *  ```\n     *  \n     *  If the meomry store contains the following paths ...\n     *  \n     *  - `/path/to/dir/doc1`\n     *  - `/path/to/dir/doc2`\n     *  - `/path/to/dir/subdir/doc3`\n     *  - `/path/to/dir/subdir/doc4`\n     *  - `/path/to/otherdir/doc5`\n     *  \n     *  ... then `entries` is `[\"doc1\", \"doc2\", \"subdir/\"]`.\n     *  \n     *  If the passed path doesn't exist, it returns `[]`.\n     */\n     list (path) {\n         const normPath = this.normalizePath(`${path}/`);\n         const items = [];\n         for (let key of this._content.keys()) {\n             if (key.indexOf(normPath) === 0) {\n                 const subPath = key.slice(normPath.length);\n                 const slashIndex = subPath.indexOf('/');\n                 const item = slashIndex === -1 ? subPath : subPath.slice(0, slashIndex+1);\n                 if (items.indexOf(item) === -1) items.push(item);\n             }\n         }\n         return items;\n     }\n\n\n    /**\n     *  memStore.write - method\n     *  ------------------------------------------------------------------------\n     *  Maps a document path to a source, in memory.\n     *  \n     *  ```js\n     *  await memStore.write(\"/path/to/doc\", source);\n     *  ```\n     *  \n     *  - If path is `path/to/x/../doc`, the content of `/path/to/doc` will\n     *    be modified with the passed source\n     *  - `source` will be always converted to string\n     */\n    write (path, source) {\n        const normPath = this.normalizePath(path);\n        return this._content.set(normPath, String(source));\n    }\n\n\n    /**\n     *  memStore.delete - method\n     *  ------------------------------------------------------------------------\n     *  Erases the doc source mapped in memory to the given path.\n     *  \n     *  ```js\n     *  await memStore.delete(\"/path/to/doc\");\n     *  ```\n     *  \n     *  - If path is `path/to/x/../doc`, the entry `/path/to/doc` will be deleted\n     */\n    delete (path) {\n        const normPath = this.normalizePath(path);\n        return this._content.delete(normPath);\n    }\n\n\n    /**\n     *  memStore.deleteAll - method\n     *  ------------------------------------------------------------------------\n     *  Erases all the docs whos path starts with the given path.\n     *  \n     *  ```js\n     *  await memStore.deleteAll(\"/path/to/\");\n     *  ```\n     *  \n     *  - If path is `path/to/x/../dir`, the entres starting by `/path/to/dir/` \n     *    will be deleted\n     */\n    deleteAll (path) {\n        const normPath = this.normalizePath(`${path}/`);\n        for (let docPath of this._content.keys()) {\n            if (docPath.indexOf(normPath) === 0) {\n                this.delete(docPath);\n            }\n        }\n    }\n}\n\nmodule.exports = MemoryStore;\n\n\n//# sourceURL=webpack:///./node_modules/@onlabsorg/olojs/lib/memory-store.js?");

/***/ }),

/***/ "./node_modules/@onlabsorg/olojs/lib/router.js":
/*!*****************************************************!*\
  !*** ./node_modules/@onlabsorg/olojs/lib/router.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\nconst document = __webpack_require__(/*! ./document */ \"./node_modules/@onlabsorg/olojs/lib/document.js\");\nconst pathlib = __webpack_require__(/*! path */ \"./node_modules/node-libs-browser/node_modules/path-browserify/index.js\");\nconst Store = __webpack_require__(/*! ./store */ \"./node_modules/@onlabsorg/olojs/lib/store.js\");\n\n\n\n/**\n *  Router\n *  ============================================================================\n *  This store is a container for other stores and routes the `read`, `list`,\n *  `write` and `delete` requests to the store best matching the path.\n *  \n *  ```js\n *  routes = {\n *      \"/path/to/store_1/\": store_1,\n *      \"/path/to/store_2/\": store_2,\n *      ...\n *  };\n *  \n *  router = new Router(routes);\n *  ```\n *  \n *  Every time a `read`, `list`, `write`, `delete` or `deleteAll` method is\n *  called on a `path`, the router delegates to the corresponding method of\n *  the store matching the path. For example, with reference to the router \n *  declaration above:\n *  \n *  - `router.read('/path/to/store_1/path/to/doc')` will result in a call to\n *    `store_1.read('/path/to/doc')`\n *  - `router.read('/path/to/store_2/path/to/doc')` will result in a call to\n *    `store_2.read('/path/to/doc')`\n *  \n *  If no match is found, it will behave as empty store, which is: `read` will\n *  return an empty string, `list` will return an empty array, `write`,\n *  `delete` and `deleteAll` will throw a `WriteOperationNotAllowed` error.\n *  \n *  The constructor will ignore the properties of the `routes` object which are \n *  not valid stores, that is objects that do not have any of the methods \n *  `read`, `list`, `write`, `delete`, `deleteAll`, `createContext`, `load`.\n *  The easiest way to create a valid store is by extending the `Store` class.\n */\nclass Router extends Store {\n\n    constructor (routes) {\n        super();\n\n        // Initialize routes\n        const validRoutes = filterObject(isStore, routes);\n        const normalizedRoutes = renameKeys(normalizeDirPath, validRoutes);\n        this._routes = sortObject(normalizedRoutes);\n    }\n\n    *_iterMatches (path) {\n        const normPath = this.normalizePath(path);\n        for (let [routeId, store] of this._routes.entries()) {\n            if (normPath.indexOf(routeId) === 0) {\n                const subPath = normPath.slice(routeId.length-1);\n                yield [store, subPath];\n            }\n        }\n    }\n\n\n    // Finds the route that best matches the given document path and returns\n    // the corresponding store and the path relative to the matching route\n    match (path) {\n        const matches = this._iterMatches(path);\n        return matches.next().value || [null, path];\n    }\n\n\n    /**\n     *  router.read - async method\n     *  ------------------------------------------------------------------------\n     *  Retrieves an olo-document from the matching sub-store.\n     *  \n     *  ```js\n     *  router = new Router({\n     *      \"/path/to/store_1/\": store_1,\n     *      \"/path/to/store_2/\": store_2,\n     *      ...\n     *  })\n     *  \n     *  source = await router.read(\"/path/to/store_i/sub/path/to/doc\");\n     *  ```\n     *  \n     *  - When requesting `/path/to/store_i/sub/path/to/doc`, it returns\n     *    `await store_i.read('/sub/path/to/doc')`.\n     *  - When no store is mounted on `/path/to/store_i/`, it returns an empty\n     *    string\n     */\n    async read (path) {\n        const [store, subPath] = this.match(path);\n        return store ? await store.read(subPath) : await super.read(path);\n    }\n\n\n    /**\n     *  router.list - async method\n     *  ------------------------------------------------------------------------\n     *  Returns the list of entry names under the passed path, considering all\n     *  the mount points.\n     *  \n     *  ```js\n     *  router = new Router({\n     *      \"/path/to/\": store0,\n     *      \"/path/to/a/s1\": store1,\n     *      \"/path/to/b/s2\": store2,\n     *      \"/path/to/s3\": store3\n     *  });\n     *  \n     *  entries = await router.list(\"/path/to\");\n     *  ```\n     *  In the given example, the array `entries` will contain `[\"a/\", \"b/\",\n     *  \"s2\"]`, plus all the items returned by `await store0.list(\"/\")`.\n     *  \n     *  If no mounted stores matches the given path, then an empty array is\n     *  returned.\n     */\n    async list (path) {\n        const dirPath = normalizeDirPath(path);\n        const entries = [];\n        for (let [store, subPath] of this._iterMatches(dirPath)) {\n            mergeLists(entries, await store.list(subPath));\n        }\n        for (let [routePath, store] of this._routes.entries()) {\n            if (routePath !== dirPath && routePath.indexOf(dirPath) === 0) {\n                const subPath = routePath.slice(dirPath.length);\n                const entry = subPath.slice(0, subPath.indexOf('/')+1);\n                pushIfMissing(entries, entry);\n            }\n        }\n        return entries;\n    }\n\n\n    /**\n     *  router.write - async method\n     *  ------------------------------------------------------------------------\n     *  Modifies an olo-document contained in the matching sub-store.\n     *  \n     *  ```js\n     *  router = new Router({\n     *      \"/path/to/store_1/\": store_1,\n     *      \"/path/to/store_2/\": store_2,\n     *      ...\n     *  })\n     *  \n     *  await router.write(\"/path/to/store_i/sub/path/to/doc\", source);\n     *  ```\n     *  \n     *  - When `/path/to/store_i/sub/path/to/doc` is passed, it calls\n     *    `await store_i.write('/sub/path/to/doc', source)`.\n     *  - When no store is mounted on `/path/to/store_i`, it throws a\n     *    `Router.WriteOperationNotAllowedError`.\n     */\n    async write (path, source) {\n        const [store, subPath] = this.match(path);\n        return store ? await store.write(subPath, source) : await super.write(path, source);\n    }\n\n\n    /**\n     *  router.delete - async method\n     *  ------------------------------------------------------------------------\n     *  Deletes an olo-document contained in the matching sub-store.\n     *  \n     *  ```js\n     *  router = new Router({\n     *      \"/path/to/store_1/\": store_1,\n     *      \"/path/to/store_2/\": store_2,\n     *      ...\n     *  })\n     *  \n     *  await router.delete(\"/path/to/store_i/sub/path/to/doc\");\n     *  ```\n     *  \n     *  - When `/path/to/store_i/sub/path/to/doc` is passed, it calls\n     *    `await store_i.delete('/sub/path/to/doc')`.\n     *  - When no store is mounted on `/path/to/store_i/`, it throws a\n     *    `Router.WriteOperationNotAllowedError`.\n     */\n    async delete (path) {\n        const [store, subPath] = this.match(path);\n        return store ? await store.delete(subPath) : await super.delete(path);\n    }\n\n\n    /**\n     *  router.deleteAll - async method\n     *  ------------------------------------------------------------------------\n     *  Deletes all the documents matching the given path.\n     *  \n     *  ```js\n     *  router = new Router({\n     *      \"/path/to/store_1/\": store_1,\n     *      \"/path/to/store_2/\": store_2,\n     *      ...\n     *  })\n     *  \n     *  await router.deleteAll(\"/path/to/store_i/sub/path/to/doc\");\n     *  ```\n     *  \n     *  - When `/path/to/store_i/sub/path/to/doc` is passed, it calls\n     *    `await store_i.deleteAll('/sub/path/to/doc')`.\n     *  - When no store is mounted on `/path/to/store_i/`, it throws a\n     *    `Router.WriteOperationNotAllowedError`.\n     */\n    async deleteAll (path) {\n        const [store, subPath] = this.match(path);\n        return store ? await store.deleteAll(subPath) : await super.deleteAll(path);\n    }\n}\n\nmodule.exports = Router;\n\n\n\n// -----------------------------------------------------------------------------\n//  SERVICE FUNCTIONS\n// -----------------------------------------------------------------------------\n\nconst isStore = obj => {\n    if (typeof obj.read !== \"function\") return false;\n    if (typeof obj.list !== \"function\") return false;\n    if (typeof obj.write !== \"function\") return false;\n    if (typeof obj.delete !== \"function\") return false;\n    if (typeof obj.deleteAll !== \"function\") return false;\n    if (typeof obj.createContext !== \"function\") return false;\n    if (typeof obj.load !== \"function\") return false;\n    return true;\n};\n\nconst renameKeys = (ren, obj) => {\n    const newObj = {};\n    for (let key in obj) newObj[ren(key)] = obj[key];\n    return newObj;\n}\n\nconst sortObject = obj => {\n    const keys = Object.keys(obj).sort().reverse();\n    const map = new Map();\n    for (let key of keys) map.set(key, obj[key]);\n    return map;\n}\n\nconst filterObject = (test, obj) => {\n    const newObj = {};\n    for (let key in obj) if (test(obj[key])) newObj[key] = obj[key];\n    return newObj;\n}\n\nconst pushIfMissing = (list, item) => {\n    if (list.indexOf(item) === -1) list.push(item);\n}\n\nconst mergeLists = (list1, list2) => {\n    for (let item of list2) pushIfMissing(list1, item);\n}\n\nconst normalizeDirPath = path => Router.prototype.normalizePath(`${path}/`);\n\n\n//# sourceURL=webpack:///./node_modules/@onlabsorg/olojs/lib/router.js?");

/***/ }),

/***/ "./node_modules/@onlabsorg/olojs/lib/store.js":
/*!****************************************************!*\
  !*** ./node_modules/@onlabsorg/olojs/lib/store.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const pathlib = __webpack_require__(/*! path */ \"./node_modules/node-libs-browser/node_modules/path-browserify/index.js\");\nconst isDirectory = path => path.slice(-1) === '/';\nconst document = __webpack_require__(/*! ./document */ \"./node_modules/@onlabsorg/olojs/lib/document.js\");\n\nconst isValidName = name => typeof name === 'string' && /^[a-z_A-Z]+[a-z_A-Z0-9]*$/.test(name);\n\n\n/**\n *  Store\n *  ============================================================================\n *  This is the base class to be used to create olojs document stores.\n *  When instantiatete directly it behaves like a read-only empty store.\n *\n *  ```js\n *  // A read-only empty store\n *  store = new Store();\n *  \n *  // A store implementation\n *  class ChildStore extends Store {\n *      async read (path) { ... }\n *      async list (path) { ... }\n *      async write (path, source) { ... }\n *      async delete (path) { ... }\n *      async deleteAll (path) { ... }\n *  ```\n */\nclass Store {\n\n    constructor () {\n        const store = this;\n\n        this.globals = {\n\n            async import (docId) {\n                const targetId = resolveId(this.__path__, docId);\n                const targetContext = store.createContext(targetId);\n                const targetPath = targetContext.__path__;\n                if (!this.$cache.has(targetPath)) {\n                    const source = await store.read(targetPath);\n                    const evaluate = document.parse(source);\n                    this.$cache.set(targetPath, [source, evaluate]);\n                }\n                const [targetSource, evaluateTarget] = this.$cache.get(targetPath);\n                return await evaluateTarget(targetContext);\n            }\n        };\n    }\n\n    /**\n     *  store.read - async method\n     *  ------------------------------------------------------------------------\n     *  Returns the source of the document mapped in this store to the given\n     *  path.\n     *\n     *  ```js\n     *  source = await store.read(\"/path/to/doc\");\n     *  ```\n     *\n     *  Every implmenentation of this method should behave according to the\n     *  following standard:\n     *\n     *  - It should return a string\n     *  - It should throw `Store.ReadPermissionDeniedError` if the store\n     *    instance has no read permission on the given path.\n     *\n     *  When instantiated directly, the base store `read` method returns always\n     *  an empty string.\n     */\n    async read (path) {\n        return \"\";\n    }\n\n\n    /**\n     *  store.list - async method\n     *  ------------------------------------------------------------------------\n     *  Returns the names of the items contained under the given path.\n     *\n     *  ```js\n     *  items = await store.list(\"/path/to\");\n     *  ```\n     *\n     *  Every implmenentation of this method should behave according to the\n     *  following standard:\n     *\n     *  - It should returns an array of strings, each containing the name of a\n     *    child item (a document or a container) of the given path; container\n     *    names differ from document names in that they end with a `/`.\n     *  - It should throw `Store.ReadPermissionDeniedError` if the store\n     *    instance has no read permission on the given path.\n     *  - It should throw `Store.ReadOperationNotAllowedError` if the store\n     *    doesn't implement listing.\n     *  \n     *  For example, if `store` contains the following documents:\n     *  \n     *  - /path/to/doc1\n     *  - /path/to/doc2\n     *  - /path/to/dir/doc3\n     *  \n     *  then then `srotes.list('/path/to')` resolves `['doc1', 'doc2', 'dir/']`.\n     *  \n     *  When instantiated directly, the base store `list` method returns always\n     *  an empty array.\n     */\n    async list (path) {\n        return [];\n    }\n\n\n    /**\n     *  store.write - async method\n     *  ------------------------------------------------------------------------\n     *  Changes the source of the document at the given path.\n     *  \n     *  ```js\n     *  await store.write(\"/path/to/doc\", \"This is the doc content.\");\n     *  ```\n     *  \n     *  Every implmenentation of this method should behave according to the\n     *  following standard:\n     *  \n     *  - After calling this method on `path`, then `store.read(path)` should\n     *    return the new source.\n     *  - It should throw `Store.WritePermissionDeniedError` if the store\n     *    instance has no write permission on the given path.\n     *  - It should throw `Store.WriteOperationNotAllowedError` if the store\n     *    is read-only.\n     *  \n     *  When instantiated directly, the base store `write` method always throws\n     *  `Store.WriteOperationNotAllowedError`.\n     */\n    async write (path, source) {\n        throw new this.constructor.WriteOperationNotAllowedError(this.normalizePath(path));\n    }\n\n\n    /**\n     *  store.delete - async method\n     *  ------------------------------------------------------------------------\n     *  Removes a document from the store.\n     *  \n     *  ```js\n     *  await store.delete(\"/path/to/doc\");\n     *  ```\n     *  \n     *  Every implmenentation of this method should behave according to the\n     *  following standard:\n     *\n     *  - After calling this method on `path`, then `store.read(path)` should\n     *    return an empty string and `store.list` should not return the name\n     *    of the removed document.\n     *  - It should throw `Store.WritePermissionDeniedError` if the store\n     *    instance has no write permission on the given path.\n     *  - It should throw `Store.WriteOperationNotAllowedError` if the store\n     *    is read-only.\n     *  \n     *  When instantiated directly, the base store `delete` method always throws\n     *  `Store.WriteOperationNotAllowedError`.\n     */\n    async delete (path) {\n        throw new this.constructor.WriteOperationNotAllowedError(this.normalizePath(path));\n    }\n\n\n    /**\n     *  store.deleteAll - async method\n     *  ------------------------------------------------------------------------\n     *  Removes all the documents whose path starts with a given path.\n     *\n     *  ```\n     *  await store.deleteAll(\"/path/to/\");\n     *  ```\n     *\n     *  Every implmenentation of this method should behave according to the\n     *  following standard:\n     *\n     *  - After calling this method on `/path/to`, then `store.read(\"/path/to/any/doc\")`\n     *    should return an empty string and `store.list` should not return the name\n     *    of any of the removed documents.\n     *  - It should throw `Store.WritePermissionDeniedError` if the store\n     *    instance has no write permission on the given path.\n     *  - It should throw `Store.WriteOperationNotAllowedError` if the store\n     *    is read-only.\n     *  \n     *  When instantiated directly, the base store `deleteAll` method always throws\n     *  `Store.WriteOperationNotAllowedError`.\n     */\n    async deleteAll (path) {\n        throw new this.constructor.WriteOperationNotAllowedError(this.normalizePath(path));\n    }\n\n\n    /**\n     *  store.createContext - method\n     *  ------------------------------------------------------------------------\n     *  Creates a document context specific to a given store document.\n     *\n     *  ```js\n     *  context = store.createContext(docId);\n     *  ```\n     *\n     *  - `docId` is a combination of a path and a query string (e.g.\n     *    `/path/to/doc?x=10;y=20;z=30`)\n     *  - `context` is a valid document context\n     *  - `context.__path__` contains the path portion of `docId`\n     *  - `context.argns` contains the namespace passed as query string with\n     *    `docId`. For example, if `docId = /path/to/doc?x=10;y=20;z=30`, then\n     *    the `argns` namespace will be `{x:10, y:20, z:30}`.\n     *  - `context.import` is a function that returns a store document namespace\n     *    given its id. If the path portion of the id is a relative path, it\n     *    will be resolved agains `context.__path__`.\n     *  \n     *  The `createContext` method is not meant to be overridden.\n     */\n    createContext (docId) {\n        const {path, argns} = Store.parseId(docId);\n        return document.createContext(\n            this.globals,\n            {$cache: new Map()},\n            {__path__: path, argns: argns}\n        );\n    }\n\n\n    /**\n     *  store.load - async method\n     *  ------------------------------------------------------------------------\n     *  Reads, evaluates and renders the document identified by the passed id.\n     *\n     *  ```js\n     *  {source, context, namespace, text} = await store.load(docId);\n     *  ```\n     *\n     *  - `docId` is a combination of a path and a query string (e.g.\n     *    `/path/to/doc?x=10;y=20;z=30`)\n     *  - `source` is the document source returned by `store.read`\n     *  - `context` is the document context returned by `store.createContext`\n     *  - `namespace` is the document namespace evaluated in `context`\n     *  - `text` is the document rendered content\n     *  \n     *  The `load` method is not meant to be overridden.\n     */\n    async load (docId) {\n        const doc = {};\n        doc.context = this.createContext(docId);\n        doc.source = await this.read(doc.context.__path__);\n        const evaluate = document.parse(doc.source);\n        doc.namespace = await evaluate(doc.context);\n        doc.text = await doc.context.str(doc.namespace);\n        return doc;\n    }\n\n\n    normalizePath (path) {\n        return pathlib.normalize(`/${path}`);\n    }\n}\n\n\n// Parses the given id string into its a store name (uri scheme), a path\n// (uri authority + uri path) and a query (uri query)\nStore.parseId = id => {\n    const queryIndex = id.indexOf('?');\n    const path = queryIndex === -1 ? id : id.slice(0, queryIndex);\n    const query = queryIndex === -1 ? \"\" : id.slice(queryIndex+1);\n    return {\n        path: pathlib.normalize(`/${path}`),\n        argns: parseParameters(...iterQuery(query))\n    }\n}\n\n\n// Given a list of argument ['par1=val1', 'par2=val2', 'par3=val3', ...],\n// converts it to an object ontaining the ke-value pair contained in the list\nfunction parseParameters (...keyValuePairs) {\n    const argns = {};\n    for (let keyValuePair of keyValuePairs) {\n        const separatorIndex = keyValuePair.indexOf(\"=\");\n        if (separatorIndex === -1) {\n            let name = keyValuePair.trim();\n            if (isValidName(name)) argns[name] = true;\n        } else {\n            let name = keyValuePair.slice(0, separatorIndex).trim();\n            if (isValidName(name)) {\n                let string = keyValuePair.slice(separatorIndex+1).trim();\n                let number = Number(string);\n                argns[name] = isNaN(number) ? string : number;\n            }\n        }\n    }\n    return argns;\n}\n\n// Iterates over all the key-value pairs contained in the query, considering\n// both `&` and `;` as separators.\nfunction *iterQuery (query) {\n    for (let ampParam of query.split('&')) {\n        for (let param of ampParam.split(';')) {\n            yield param;\n        }\n    }\n}\n\n\n\n// Base class for Store.ReadPermissionDeniedError and\n// Store.WritePermissionDeniedError.\nclass PermissionDeniedError extends Error {\n\n    constructor (operation, path) {\n        super(`Permission denied: ${operation} ${path}`);\n    }\n}\n\n/**\n *  Store.ReadPermissionDeniedError - class\n *  ----------------------------------------------------------------------------\n *  Error thrown when attempting a read operation for which the store instance\n *  has no read access.\n *\n *  ```js\n *  throw new Store.ReadPermissionDeniedError('/path/to/doc');\n *  ```\n */\nStore.ReadPermissionDeniedError = class extends PermissionDeniedError {\n\n    constructor (path) {\n        super(\"READ\", path);\n    }\n}\n\n/**\n *  Store.WritePermissionDeniedError - class\n *  ----------------------------------------------------------------------------\n *  Error thrown when attempting a write operation for which the store instance\n *  has no write access.\n *\n *  ```js\n *  throw new Store.WritePermissionDeniedError('/path/to/doc');\n *  ```\n */\nStore.WritePermissionDeniedError = class extends PermissionDeniedError {\n\n    constructor (path) {\n        super(\"WRITE\", path);\n    }\n}\n\n\n\n// Base class for Store.ReadOperationNotAllowedError and\n// Store.WriteOperationNotAllowedError.\nclass OperationNotAllowedError extends Error {\n\n    constructor (operation, path) {\n        super(`Operation not allowed: ${operation} ${path}`);\n    }\n}\n\n/**\n *  Store.ReadOperationNotAllowedError - class\n *  ----------------------------------------------------------------------------\n *  Error thrown when the read operation is not defined on the store.\n *\n *  ```js\n *  throw new Store.ReadOperationNotAllowedError('/path/to/doc');\n *  ```\n */\nStore.ReadOperationNotAllowedError = class extends OperationNotAllowedError {\n\n    constructor (path) {\n        super(\"READ\", path);\n    }\n}\n\n/**\n *  Store.WriteOperationNotAllowedError - class\n *  ----------------------------------------------------------------------------\n *  Error thrown when the write operation is not defined on the store.\n *\n *  ```js\n *  throw new Store.WriteOperationNotAllowedError('/path/to/doc');\n *  ```\n */\nStore.WriteOperationNotAllowedError = class extends OperationNotAllowedError {\n\n    constructor (path) {\n        super(\"WRITE\", path);\n    }\n}\n\n\n\nmodule.exports = Store;\n\n\nfunction resolveId (basePath, relativeId) {\n    const relativePath = relativeId.split('?')[0];\n    const query = relativeId.slice(relativePath.length);\n    if (relativePath[0] === '/') {\n        return pathlib.normalize(relativePath) + query;\n    } else {\n        const baseDirPath = basePath.slice(-1) === '/' ? basePath : pathlib.resolve(basePath, '..');\n        return pathlib.join(baseDirPath, relativePath) + query;\n    }\n}\n\n\n//# sourceURL=webpack:///./node_modules/@onlabsorg/olojs/lib/store.js?");

/***/ }),

/***/ "./node_modules/@onlabsorg/olojs/lib/viewer.js":
/*!*****************************************************!*\
  !*** ./node_modules/@onlabsorg/olojs/lib/viewer.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const DOMPurify = __webpack_require__(/*! dompurify */ \"./node_modules/dompurify/dist/purify.js\");\n\n\n\n/**\n *  Viewer - function\n *  ============================================================================\n *  The Viewer function takes a DOM element and an olojs Store as input and\n *  binds the `innerHTML` content of the element to the rendering of the document \n *  identified by the `src` attribute in the given store. For example:\n *  \n *  ```html\n *  \n *  <!-- This is the element that will contain the document rendering -->\n *  <div id=\"viewer-id\" src=\"/path/to/doc\"></div>\n *  \n *  <script>\n *      \n *      <!-- retrieve the host element and create a store -->\n *      domElement = document.querySelector(\"#viewer-id\");\n *      store = new olojs.HTTPStore(\"http://store-hostname\");\n *      \n *      <!-- bind the host element to the store -->\n *      viewer = olojs.Viewer(domElement, store);\n *      \n *  </store>\n *  ```\n *  \n *  Once the binding is created by calling the `Viewer` constructor, the\n *  document identified by the `src` attribute (`/path/to/doc` in the example)\n *  will be loaded from the given store, then rendered, sanitized and injected\n *  as `innerHTML` in the host element.\n *  \n *  Every time the `src` attribute changes, the host element content will be\n *  automatically updated. \n *  \n *  The Viewer constructor returns the [MutationObserver](https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver)\n *  used to react to `src` attribute changes.\n */\nmodule.exports = function (element, store) {\n    \n    const observer = new MutationObserver(async mutations => {\n        for (let mutation of mutations) {\n            if (mutation.type === \"attributes\" && mutation.attributeName === \"src\") {\n                const docId = mutation.target.getAttribute('src');\n                const {text} = await store.load(docId);\n                mutation.target.innerHTML = DOMPurify.sanitize(text);\n            }\n        }\n    });\n    \n    observer.observe(element, {\n        attributes: true, \n        attributeFilter: ['src']\n    });\n    \n    return observer;\n}\n\n\n//# sourceURL=webpack:///./node_modules/@onlabsorg/olojs/lib/viewer.js?");

/***/ }),

/***/ "./node_modules/@onlabsorg/swan-js/index.js":
/*!**************************************************!*\
  !*** ./node_modules/@onlabsorg/swan-js/index.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n *  swan\n *  ============================================================================\n *  The swan JavaScript API include a `parse` function and a `createContext`\n *  function to parse and evaluate expressions. \n *  Furthermore, it contains a `defineModule` to add custom javascript modules \n *  to the swan standard library and the types `Tuple` and `Undefined` which\n *  are the only two swan types that do not correspond to a javascript negative\n *  type.\n */\n \nconst {Tuple, Undefined, parse, context} = __webpack_require__(/*! ./lib/interpreter */ \"./node_modules/@onlabsorg/swan-js/lib/interpreter.js\");\nconst modules = __webpack_require__(/*! ./lib/modules */ \"./node_modules/@onlabsorg/swan-js/lib/modules.js\");\ncontext.require = modules.require;\n\n\n\n/**\n *  swan.parse - function\n *  ----------------------------------------------------------------------------\n *  Parses a swan expression and returns a function that maps a context to an\n *  expression value.\n *  \n *  ```js\n *  evaluate = swan.parse(expression);\n *  value = await evaluate(context);\n *  ```\n *  - `espression` is a string containing any valid swan expression\n *  - `context` is a valid swan expression context\n *  - `value` is the value that expression result has in the given context\n */\n\nexports.parse = function (expression) {\n    const evaluate = parse(expression);\n    return async (ctx) => {\n        if (!context.isPrototypeOf(ctx)) {\n            throw new Error(\"Invalid context!\");\n        }\n        const value = await evaluate(ctx);\n        return Tuple(value).normalize();\n    }\n}\n\n\n\n/**\n *  swan.createContext - function\n *  ----------------------------------------------------------------------------\n *  Creates a valid expression context.\n *  ```js\n *  context = swan.createContext(...namespaces)\n *  ```\n *  - `namespaces` is a list of objects `ns1, ns2, ns3, ...` that will be merged\n *    to the core swan context\n *  - `context` is an object containing all the core context properties, plus\n *    all the properties of the passed namespace, added in order.\n */\nexports.createContext = function (...namespaces) {\n    \n    if (namespaces.length === 0) {\n        return context.$extend({});\n    }\n    \n    let ctx = context;\n    for (let namespace of namespaces) {\n        ctx = ctx.$extend(namespace);\n    }\n    return ctx;\n}\n\n\n\n/**\n *  swan.defineModule - function\n *  ----------------------------------------------------------------------------\n *  Adds a module to the swan library. The module can be then loaded with\n *  the built-in `require` function.\n *  ```js\n *  swan.defineModule(modulePath, moduleLoader)\n *  ```\n *  - `modulePath` a `/-separated` path that identifies the module\n *  - `moduleLoader` an asynchronous function that returns the module\n */\nexports.defineModule = modules.define;\n\n\n\n/**\n *  swan.Tuple - function\n *  ----------------------------------------------------------------------------\n *  This function creates a swan tuple object.\n *  ```js\n *  tuple = Tuple(item1, item2, ...)\n *  tuple instanceof Tuple      // true\n *  ```\n */\nexports.Tuple = Tuple;\n\n\n\n/**\n *  swan.Undefined - function\n *  ----------------------------------------------------------------------------\n *  This function creates a swan undefined object.\n *  ```js\n *  undef = Undefined(...args)\n *  undef instanceof Undefined      // true\n *  ```\n */\nexports.Undefined = function (...args) {\n    return new Undefined(...args);\n}\nexports.Undefined.prototype = Undefined.prototype;\n\n\n//# sourceURL=webpack:///./node_modules/@onlabsorg/swan-js/index.js?");

/***/ }),

/***/ "./node_modules/@onlabsorg/swan-js/lib/interpreter.js":
/*!************************************************************!*\
  !*** ./node_modules/@onlabsorg/swan-js/lib/interpreter.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n *  SWAN INTERPRETER MODULE\n *  ============================================================================\n *   \n *  This module exposes a `parse` function that takes a text containin a swan \n *  expression and returns an `evaluate` function that, once run returns the \n *  value of the original expression.\n *  \n *      evaluate = interpreter.parse(\"2 + 3 * 4\");\n *     value = await evaluate(context);    // -> 24\n *  \n *  The context object passed to the `evaluate` function must have \n *  `interpreter.context` as prototype. \n *  \n *     context = interpreter.context.$extend({pi:3.14, double: x => 2*x})\n *  \n *  All the properties added to the context (e.g. `pi` and `double` in the \n *  example above) can be referenced in the expression.\n *\n *  ----------------------------------------------------------------------------\n *  \n *  Besides the two core exports `interpreter.parse` and `interpreter.context`,\n *  this module exports also the following two calsses:\n *  \n *  - interpreter.Tuple\n *  - interpreter.Undefined\n *  \n *  Tuple and Undefined are the only two swan type that do not already exist in \n *  javascript.\n *  \n *  `Tuple` is the swan product type (item1, item2, ...). The elements of a tuple \n *  are called `items`. Each item can also be seen as a tuple made of only one\n *  element. Tuples are flattened, therefore a tuple cannot contain nested tuples; \n *  in other words, the tuple (i1, (i2, i3), i4) is equivalent to the tuple \n *  (i1, i2, i3, i4).\n *  \n *  The empty tuple () is the unit type of swan and it is used to represent \n *  the concept of nothingness. It is therefore also called `NOTHING`.\n *  \n *  `Undefined` is the value an expression returns when the results of the \n *  expression is not defined. For example the division of number by NOTHING is \n *  not defined in swan, therefore the expression `3 / ()` will return an \n *  instance of undefined.\n *  \n *  swan doesn't have the concept of Exception: where other languages throw an\n *  exception, swan returns an Undefined value. The Undefined objects contain \n *  also information that can help the swan user to trace back the origin of the \n *  undefined value (think at it as a sort of error stack).\n *  \n *  ----------------------------------------------------------------------------\n *\n *  Besides the Tuple product type and the Undefined item type, swan has the\n *  following item types. Each of them corresponds to a JavaScript type.\n *  \n *  - Boolean       (equivalent to the JavaScript Boolean type)\n *  - Number        (equivalent to the JavaScript Number type)\n *  - String        (equivalent to the JavaScript String type)\n *  - List          (equivalent to the JavaScript Array type)\n *  - Namespace     (equivalent to the JavaScript Object type)\n *  - Function      (equivalent to the JavaScript Function type)\n */\n\n\n\n\n\n// -----------------------------------------------------------------------------\n//  TYPE DETECTION\n// -----------------------------------------------------------------------------\n\n// This function takes an item as input and returns its type name\nfunction detectItemType (item) {\n        \n    // if primitive\n    switch (typeof item) {\n        case \"boolean\"  : return \"Boolean\";\n        case \"number\"   : return \"Number\";\n        case \"string\"   : return \"String\";\n        case \"function\" : return \"Function\";\n    }    \n    \n    // It must be an object!\n    \n    // if a List\n    if (Array.isArray(item)) return \"List\";\n    \n    // if undefined\n    if (item instanceof Undefined) return \"Undefined\";\n    \n    // if a primitive object\n    switch (Object.prototype.toString.call(item)) {\n        case '[object Boolean]'  : return \"Boolean\";\n        case '[object Number]'   : return \"Number\";\n        case '[object String]'   : return \"String\";\n        case '[object Function]' : return \"Function\";\n    }\n    \n    // It is a Namespace!\n    return \"Namespace\";        \n}\n\n// The following functions return true or false if the passed item matches a certain type\nconst isNothing = x => x === null || x === undefined || Number.isNaN(x);\nconst isBoolean = x => typeof x === 'boolean' || (typeof x === 'object' && Object.prototype.toString.call(x) === '[object Boolean]')\nconst isNumber = x => typeof x === 'number' || (typeof x === 'object' && Object.prototype.toString.call(x) === '[object Number]')\nconst isFunction = x => typeof x === 'function' || (typeof x === 'object' && Object.prototype.toString.call(x) === '[object Function]')\nconst isString = x => typeof x === 'string' || (typeof x === 'object' && Object.prototype.toString.call(x) === '[object String]');\nconst isList = x => x && Array.isArray(x);\nconst isNamespace = x => detectItemType(x) === 'Namespace';\n\n// The following function checks if a string is a valid swan identifier\nconst isName = x => isString(x) && /^[a-z_A-Z]+[a-z_A-Z0-9]*$/.test(x);\n\n// This function takes two items as input and returns the concatenation of \n// their type names. For example `detectType(1,[])` returns \"Number,List\".\n// This is mostly used by binary operation handlers to decide at runtime how\n// to reduce the two operators, based on their type.\nfunction detectPairType (value1, value2) {\n    return `${detectItemType(value1)},${detectItemType(value2)}`;\n}\n\n\n\n\n\n// -----------------------------------------------------------------------------\n//  TYPE CASTING\n// -----------------------------------------------------------------------------\n\n// This functions defines the boolean type casting behaviour of swan\nfunction convertItemToBoolean (item) {\n    switch (detectItemType(item)) {\n        \n        case \"Boolean\"  : return item;                              // A boolean is already a boolean\n        case \"Number\"   : return item !== 0;                        // A number is false only if it is 0\n        case \"String\"   : return item !== \"\";                       // A string is false only if it is empty\n        case \"List\"     : return item.length !== 0;                 // A list is false only if it is empty\n        case \"Namespace\": return countNamespaceNames(item) !== 0;   // A namespace is false only if it is empty\n        case \"Function\" : return true;                              // A function is always true\n        \n        // The following should never run!\n        default         : throw new Error(`Cannot convert ${item} to boolean`);\n    }                \n}\n\n\n\n\n\n// -----------------------------------------------------------------------------\n//  TUPLES\n// -----------------------------------------------------------------------------\n\n// Shortcut for `new TupleObject`. In addition to that, this function will not\n// create a new tuple if the passed parameter is already a TupleObject.\nfunction Tuple (...items) {\n    if (items.length === 1 && items[0] instanceof TupleObject) return items[0];\n    return new TupleObject(...items);\n}\n\n// This class defines the behaviour of a the swan product type. Since every\n// value in swan is a Tuple, this class is very important and you see it used\n// a lot in this module.\nclass TupleObject {\n\n    // Creates an Tuple instance given a sequence of values. The passed values\n    // can items and/or tuples. The iterator function will take care of flattening\n    // the tuple, so that `new TupleObject(a, new TupleObject(b, c))` is\n    // equivalent to `new TupleObject(a, b, c)`.\n    constructor (...items) {\n        this._items = items;\n    }\n    \n    // Yields one by one all the items contained in the tuple instance, flattening\n    // nested tuple. In particular, NOTHING values are ignored, because (a,(),b) \n    // should consistently be flattened to (a,b).\n    *[Symbol.iterator] () {\n        for (let item of this._items) {\n            if (item instanceof this.constructor) {\n                for (let subItem of item) yield subItem;\n            } else if (!isNothing(item)) {\n                yield item;\n            }\n        }\n    }\n    \n    // This method returns true if the Tuple instance has no elements\n    isEmpty () {\n        let iterator = this[Symbol.iterator]();\n        let first = iterator.next();\n        return first.done;\n    }\n    \n    // Applies synchronously the passed function to each item of this tuple\n    // and returns the resulting tuple.\n    mapSync (f) {\n        let image = new this.constructor();\n        for (let item of this) {\n            image = new this.constructor(image, f(item));\n        }\n        return image;\n    }\n\n    // Applies asynchronously the passed function to each item of this tuple\n    // and returns the resulting tuple.\n    async mapAsync (f) {\n        let image = new this.constructor();\n        for (let item of this) {\n            image = new this.constructor(image, await f(item));\n        }\n        return image;\n    }\n    \n    // If this tuple is empty it returns `null` (JavaScript equivalent to NOTHING);\n    // if this tuple contains only one item, it returns the tuple;\n    // if this tuple contains two or more items, it returns this tuple itself.\n    normalize () {\n        let iterator = this[Symbol.iterator]();\n        let first = iterator.next();\n        if (first.done) return null;\n        return iterator.next().done ? first.value : this;\n    }\n}\n\n// Make sure that a tuple created with the Tuple function is recognized as\n// `instanceof` the Tuple function.\nTuple.prototype = TupleObject.prototype;\n\n// This function takes two tuples (x1, x2, ...) and (y1, y2, ...) as argument\n// and yields the pairs [x1, y1], [x2, y2], etc. If one of the tuples is\n// shorter that the other, the missing items are replaced by null (NOTHING).\n// For example (x1, x2, x3) and (y1, y2) pair to [x1,y1], [x2,y2], [x3,null].\nfunction *iterPairs (x, y) {\n    const iX = Tuple(x)[Symbol.iterator]();\n    const iY = Tuple(y)[Symbol.iterator]();\n    while (true) {\n        let x = iX.next();\n        let y = iY.next();\n        if (x.done && y.done) break;\n        yield [x.value, y.value];\n    }    \n}\n\n// This function takes two tuples (x1, x2, ...) and (y1, y2, ...) as argument\n// and returns the tuple (map(x1,y1), map(x2,y2), ...).\n// This function is often used by binary operation which normally operates on\n// each pair individually; for example (x1,x2) + (y1,y2) = (x1+y1, x2+y2).\nfunction mapPairs (x, y, map) {\n    const pairsMapping = [];\n    for (let [xItem, yItem] of iterPairs(x,y)) {\n        pairsMapping.push( map(xItem, yItem) );\n    }\n    return Tuple(...pairsMapping).normalize();\n}\n\n\n\n\n// -----------------------------------------------------------------------------\n//  NAMESPACES\n// -----------------------------------------------------------------------------\n//  A swan namespace is a subset of a JavaScript object. The keys are called\n//  `names` and all the keys that are not valid identifiers (see isName function),\n//  are ignored.\n// -----------------------------------------------------------------------------\n\n// This function returns an array of all the valid names contained in the \n// passed namespace.\nfunction listNamespaceNames (namespace) {\n    const names = [];\n    for (let name in namespace) {\n        if (isName(name)) names.push(name);\n    }\n    return names;\n}\n\n// This function returns the number of valid names contained in the passed\n// namespace.\nfunction countNamespaceNames (namespace) {\n    let count = 0;\n    for (let name in namespace) {\n        if (isName(name)) count++;\n    }\n    return count;\n}\n\n// This function returns the value mapped to the given name in the given\n// namespace. If the name doesn't exist or it is not a valid name, it returns\n// null (NOTHING). If the name is a core JavaScript Object name, it also\n// returns null (NOTHING); this behaviour is meant to sandbox swan.\nfunction getNamespaceAttribute (namespace, name) {\n    if (!isName(name)) return null;\n    const value = namespace[name];\n    return (value !== undefined && value !== Object.prototype[name]) ? value : null;\n}\n\n\n\n\n\n// -----------------------------------------------------------------------------\n//  SEQUENCES\n// -----------------------------------------------------------------------------\n//  The following functions help manipulate Strings and Lists (Arrays)\n// -----------------------------------------------------------------------------\n\n// Given a sequence (String or List) and a number, it returns the corresponding\n// character (if a String) or item (if a List). This function accept negative\n// indexes and consider them as relative to the length of the sequence.\n// If the index is out of range, the given defaultValue is returned.\nfunction getSequenceItem (sequence, index, defaultValue) {\n    if (!isNumber(index)) return defaultValue;\n    index = index < 0 ? sequence.length + index : index;\n    return (0 <= index && index < sequence.length) ? sequence[Math.trunc(index)] : defaultValue;\n}\n\n// This function implements the JavaScript String.prototype.repeat on lists.\nfunction repeatList (list, n) {\n    var product = [];\n    for (let i=1; i<=n; i++) product = product.concat(list);\n    return product;    \n}\n\n\n\n\n\n// -----------------------------------------------------------------------------\n//  NUMBERS\n// -----------------------------------------------------------------------------\n\n// This function returns the list of integers between 0 and n.\nfunction* aritmeticSequence1 (n) {\n    if (n > 0) {\n        for (let i=0; i<n; i++) yield i;\n    } else if (n < 0) {\n        for (let i=0; i>n; i--) yield i;\n    }\n}\n\n\n\n\n\n// -----------------------------------------------------------------------------\n//  UNDEFINED\n// -----------------------------------------------------------------------------\n\n// The swan undefined data type is used as a result value of operations that are \n// not defined. For example `10 < \"abc\"` returns an Undefined instance.\n// Swan does not implement Error/Exceptions; where other languages would throw\n// an exception, swan returns an Undefined value.\n// In order to not loose information, any Undefined instance contains the name\n// of the undefined operation and all its operands. These informations allow\n// to trace back the chain of undefined operations.\nclass Undefined {\n    \n    // The constructor accepts as parameters the name of the undefined operation\n    // and all the operator values.\n    constructor (...args) {\n        this.args = Tuple(...args);\n    }\n}\n\n\n\n\n\n// -----------------------------------------------------------------------------\n//  COMPARISON\n// -----------------------------------------------------------------------------\n\n// Returns true if two tuples have the same items (uses isSameItem function).\nfunction isSameTuple (tuple1, tuple2) {\n    for (let [item1, item2] of iterPairs(tuple1, tuple2)) {\n        if (!isSameItem(item1, item2)) return false;\n    }\n    return true;\n}\n\n// Runs a deep comparison of the two namespaces and returns true if the two\n// namespaces have the same items. Non-valid names are ignored.\nfunction isSameNamespace (namespace1, namespace2) {\n    const nameList1 = listNamespaceNames(namespace1);   // only valid names\n    const nameList2 = listNamespaceNames(namespace2);   // only valid names\n    if (nameList1.length !== nameList2.length) return false;\n    for (let name of nameList1) {\n        const value1 = getNamespaceAttribute(namespace1, name);\n        const value2 = getNamespaceAttribute(namespace2, name);\n        if (!isSameTuple(value1, value2)) return false;     // in the most general case, the two items are tuples\n    }\n    return true;\n}\n\n// Returns true if two items are equal. This function defined the swan\n// concept of item equality.\nfunction isSameItem (item1, item2) {\n    \n    // NOTHING is equal only to itself\n    if (isNothing(item1) && !isNothing(item2)) return false;\n    if (isNothing(item2)) return false;    \n    \n    switch (detectPairType(item1, item2)) {\n        case \"List,List\"          : return isSameList(item1, item2);        // lists are equal if all their items are equal\n        case \"Namespace,Namespace\": return isSameNamespace(item1, item2);   // namespaces are equal if all their items are equal\n        default                   : return item1 === item2;                 // all the other item types are equal according to the JavaScript definition of equality\n    }    \n}\n\n// Returns true if the two lists have the same items\nfunction isSameList (list1, list2) {\n    if (list1.length !== list2.length) return false;\n    for (let i=0; i<list1.length; i++) {\n        if(!isSameTuple(list1[i], list2[i])) return false;\n    }\n    return true;\n}\n\n// Runs a lexicographycal comparison of the two tuples and returns \n// -1 (for <), 0 (for ==) or +1 (for >).\nfunction compareTuples (tuple1, tuple2) {\n    for (let [item1, item2] of iterPairs(tuple1, tuple2)) {\n        let cmp = compareItems(item1, item2);\n        if (cmp !== 0) return cmp;\n    }\n    return 0;   \n}\n\n// Compare two items and returns -1 (for <), 0 (for ==) or +1 (for >).\n// It throws an exception if the comparison is not defined. This exception will\n// be catched and turned into an Undefined instance.\nfunction compareItems (item1, item2) {\n    \n    // NOTHING is equal to itself and less than anything else\n    if (isNothing(item1)) return isNothing(item2) ? 0 : -1;\n    if (isNothing(item2)) return +1;\n    \n    switch (detectPairType(item1, item2)) {\n        case \"Boolean,Boolean\": return item1 === item2 ? 0 : (item1 ? +1 : -1);         // FALSE == FALSE < TRUE == TRUE\n        case \"Number,Number\"  : return item1 === item2 ? 0 : (item1<item2 ? -1 : +1);   // As per JavaScript number comparison\n        case \"String,String\"  : return item1.localeCompare(item2);                      // Alphabetical comparison\n        case \"List,List\"      : return lexCompareLists(item1, item2);                   // Lexicographical comparison\n        \n        // this exception will be catched by the proper context handler and turned into an Undefined instance\n        default               : throw new Error(`Comparison operation not defined`);        \n    }    \n}\n\n// Runs a lexicographycal comparison of the two lists and returns \n//  -1 if tuple1 < tuple2; \n//  +1 if tuple1 > tuple2; \n//  0 if tuple1 == tuple2.\nfunction lexCompareLists (list1, list2) {\n    const maxLength = Math.max(list1.length, list2.length);\n    for (let i=0; i<maxLength; i++) {\n        const cmp = compareTuples(list1[i], list2[i]);\n        if (cmp !== 0) return cmp;\n    }\n    return 0;\n}\n\n\n\n\n\n// -----------------------------------------------------------------------------\n//  PARSER\n// -----------------------------------------------------------------------------\n// The `parse` function takes a swan expression string as input and returns an \n// `evaluate` function as output.\n//\n// The `evaluate` function takes a context object as input and returns the value \n// of the swan expression as output. The evaluation of each single operation\n// is delegated to a handler attached to the context object. The handlers\n// names are defined in the configuration parameter passed to the `Parser`\n// factory. For example the `*` operation is handled by `context.$mul`.\n//\n// Each handler gets called with two parameters (for binary operations) or with\n// one parameter (for non-binary operations). Each parameter is an evaluate\n// function that returns an operand. For example, in the expression \"(3+2)*(5-1)\",\n// the `evaluate` function will return `context.$mul(X,Y)`, where: \n//  `X` is a function that takes `context` as argument and returns `(3+2)`;\n//  `Y` is a function that takes `context` as argument and returns `(5-1)`.\n//\n// More details about the parser can be found in the `parser` module.\n// -----------------------------------------------------------------------------\n\nconst Parser = __webpack_require__(/*! ./parser */ \"./node_modules/@onlabsorg/swan-js/lib/parser.js\");\n\nconst parser = new Parser({\n\n     binaryOperations: {\n         \",\"  : {precedence:10, handler:\"$pair\"    },\n         \":\"  : {precedence:12, handler:\"$label\"   },\n         \"=\"  : {precedence:12, handler:\"$set\"     },\n         \"=>\" : {precedence:13, handler:\"$tmap\"    },\n         \"?>\" : {precedence:13, handler:\"$umap\"   },\n         \">>\" : {precedence:14, handler:\"$pipe\" },\n         \"<<\" : {precedence:14, handler:\"$compose\", right:true},\n         \"->\" : {precedence:15, handler:\"$def\",     right:true},\n\n         \";\"  : {precedence:21, handler:\"$else\"},\n         \"?\"  : {precedence:22, handler:\"$if\"  },\n         \"|\"  : {precedence:23, handler:\"$or\"  },\n         \"&\"  : {precedence:23, handler:\"$and\" },\n         \"==\" : {precedence:24, handler:\"$eq\"  },\n         \"!=\" : {precedence:24, handler:\"$ne\"  },\n         \"<\"  : {precedence:24, handler:\"$lt\"  },\n         \"<=\" : {precedence:24, handler:\"$le\"  },\n         \">\"  : {precedence:24, handler:\"$gt\"  },\n         \">=\" : {precedence:24, handler:\"$ge\"  },\n         \"+\"  : {precedence:25, handler:\"$add\" },\n         \"-\"  : {precedence:25, handler:\"$sub\" },\n         \"*\"  : {precedence:26, handler:\"$mul\" },\n         \"/\"  : {precedence:26, handler:\"$div\" },\n         \"%\"  : {precedence:26, handler:\"$mod\" },\n         \"^\"  : {precedence:27, handler:\"$pow\" },\n\n         \".\"  : {precedence:30, handler:\"$dot\" },\n         \"@\"  : {precedence:30, handler:\"$at\" },\n         \"\"   : {precedence:30, handler:\"$apply\" },\n     },\n     \n     unaryOperations: {\n        \"+\": \"$id\",\n        \"-\": \"$neg\"\n     },\n\n     voidHandler        : \"$nothing\",\n     nameHandler        : \"$name\",\n     stringHandler1     : \"$str1\",\n     stringHandler2     : \"$str2\",\n     stringHandler3     : \"$strt\",\n     numberHandler      : \"$numb\",\n     squareGroupHandler : \"$list\",\n     curlyGroupHandler  : \"$namespace\",\n     \n     errorHandler       : \"$error\"\n});\n\nconst parse = source => parser.parse(source);\n\n\n\n\n\n// -----------------------------------------------------------------------------\n//  CONTEXT\n// -----------------------------------------------------------------------------\n\nconst context = {\n\n    \n    //:::  CORE HANDLERS  ::::::::::::::::::::::::::::::::::::::::::::::::::::::\n\n    // Nothing value handler\n    $nothing () {\n        return null;\n    },\n\n    // Single quote string value handler\n    $str1 (value) {\n        return value;\n    },\n\n    // Double quote string value handler\n    $str2 (value) {\n        return value;\n    },\n\n    // Template string handler\n    async $strt (value) {\n        const expressions = [];\n        value = value.replace(/\\${([\\s\\S]+?)}/g, (match, expression) => {\n            const i = expressions.length;\n            expressions.push( parse(expression) );\n            return \"${\" + i + \"}\";\n        });\n        for (let i=0; i<expressions.length; i++) {\n            const evaluateXp = expressions[i];\n            const xpVal = await evaluateXp(this);\n            const xpStr = await this.str(xpVal);\n            value = value.replace(\"${\" + i + \"}\", xpStr);\n        }\n        return value;\n    },\n\n    // Numeric value handler\n    $numb (value) {\n        return value;\n    },\n    \n    // Pairing operation handler: X,Y\n    async $pair (X, Y) {\n        return Tuple(await X(this), await Y(this));\n    },\n\n    // Square brackets grouping handler: [X]\n    async $list (X) {\n        const x = await X(this);\n        return Array.from(Tuple(x));\n    },\n\n    // Identifier handler\n    async $name (name) {\n        return getNamespaceAttribute(this, name);\n    },\n\n    // Labelling operation handler: X: Y\n    async $label (X, Y) {\n        const x = await X({\n            $$parser: this.$$parser,\n            $nothing: this.$nothing,\n            $name: name => name,\n            $pair: this.$pair,\n            $error: this.$error.bind(this)\n        });\n        const names = Array.from(Tuple(x)).filter(isName);\n\n        const y = await Y(this);        \n        const values = Array.from(Tuple(y));\n        \n        if (values.length > names.length) {\n            values[names.length-1] = Tuple(...values.slice(names.length-1)).normalize();\n        }\n        for (var i=0; i<names.length; i++) {\n            this[names[i]] = i < values.length ? values[i] : null;\n        }    \n        \n        return y;\n    },\n\n    // Assignment handler: X = Y\n    async $set (X, Y) {\n        await this.$label(X, Y);\n        return null;\n    },\n\n    // Curly braces grouping handler: {X}\n    async $namespace (X) {\n        const context = Object.create(this);\n        await X(context);\n        return Object.assign({}, context);\n    },\n\n    // Function definition operation handler: X -> Y\n    $def (params, expression) {\n        return async (...args) => {\n            const functionContext = Object.create(this);\n            await functionContext.$set(params, () => Tuple(...args).normalize());\n            return await expression(functionContext);\n        }\n    },\n    \n    // Application operation handler: X Y\n    async $apply (F, X, pos) {\n        const f = await F(this);\n        const x = Tuple(await X(this));\n        \n        return await Tuple(f).mapAsync(async fItem => {\n            \n            switch (detectItemType(fItem)) {\n                \n                case \"Function\":\n                    try {\n                        return await fItem.call(this, ...x);\n                    } catch (error) {\n                        return await this.$error(error, pos);\n                    }    \n                    \n                case \"Namespace\":\n                    if (isFunction(fItem.__apply__)) {\n                        try {\n                            return await fItem.__apply__.call(this, ...x);\n                        } catch (error) {\n                            return await this.$error(error, pos);\n                        }                            \n                    }\n                \n                default:\n                    return this.undefined('application', fItem, pos);\n            }\n        }).then(tuple => tuple.normalize());\n    },\n\n    // Referencing operation handler: X @ Y\n    async $at (X, Y, pos) {\n        const x = await X(this);\n        const y = await Y(this);\n        \n        return await Tuple(x).mapAsync(async xItem => {\n            \n            const xItemType = detectItemType(xItem);\n            switch (xItemType) {\n                case \"Namespace\": return Tuple(y).mapSync(name => getNamespaceAttribute(xItem, name)).normalize();\n                case \"List\"     : return Tuple(y).mapSync(i => getSequenceItem(xItem, i, null)).normalize();\n                case \"String\"   : return Tuple(y).mapSync(i => getSequenceItem(xItem, i, \"\")).normalize();\n                default         : return this.undefined('referencing', xItem, y, pos);\n            }\n            \n        }).then(tuple => tuple.normalize());\n    },\n\n    // Mapping operation handler: X => Y\n    async $tmap (X, F) {\n        const x = await X(this);\n        return await Tuple(x)\n                .mapAsync(item => this.$apply(F, ()=>item))\n                .then(tuple => tuple.normalize());\n    },\n\n    // Selective undefined mapping operation handler: X ?> Y\n    async $umap (X, F) {\n        const x = await X(this);\n        return await Tuple(x).mapAsync(async item => {\n            if (item instanceof Undefined) {\n                return await this.$apply(F, () => Tuple(...item.args));\n            } else {\n                return item;\n            }\n        }).then(tuple => tuple.normalize());\n    },\n    \n    // Subcontexting operation handler: X.Y\n    async $dot (X, Y, pos) {\n        const x = await X(this);\n        return await Tuple(x).mapAsync(async xItem => {\n            \n            if (!isNamespace(xItem)) {\n                return this.undefined('subcontexting', xItem, pos);\n            }\n            const childNamespace = this.$extend(xItem);\n            return await Y(childNamespace);\n            \n        }).then(tuple => tuple.normalize());\n    },\n    \n    // Hanldes all errors occurring during evaluation\n    $error (error, pos) {\n        return this.undefined('failure', error, pos);\n    },\n\n\n    //:::  UNARY OPERATION HANDLERS  :::::::::::::::::::::::::::::::::::::::::::\n\n    // Unary operation: +X\n    async $id (X) {\n        return await X(this);\n    },\n    \n    // Unary operation: -X\n    async $neg (X, pos) {\n        const x = await X(this);\n        return Tuple(x).mapSync(item => {\n            return isNumber(item) ? -item : this.undefined('negation', item, pos);\n        });\n    },\n\n\n    //:::  LOGIC OPERATION HANDLERS  :::::::::::::::::::::::::::::::::::::::::::\n\n    // OR operation handler: X | Y\n    async $or (X, Y) {\n        const x = await X(this);\n        const bool_x = await this.bool(x);\n        if (bool_x instanceof Undefined) return bool_x;\n        return bool_x ? x : await Y(this);\n    },\n\n    // AND operation handler: X & Y\n    async $and (X, Y) {\n        const x = await X(this);\n        const bool_x = await this.bool(x);\n        if (bool_x instanceof Undefined) return bool_x;\n        return bool_x ? await Y(this) : x;\n    },\n\n    // Conditional operation handler: X ? Y\n    async $if (X, Y) {\n        const x = await X(this);\n        const bool_x = await this.bool(x);\n        if (bool_x instanceof Undefined) return bool_x;\n        return bool_x ? await Y(this) : null;\n    },\n\n    // Alternative operation handler: X ; Y\n    async $else (X, Y) {\n        const x = await X(this);\n        return Tuple(x).isEmpty() ? await Y(this) : x;\n    },\n\n\n\n    //:::  ARITHMETIC OPERATION HANDLERS  ::::::::::::::::::::::::::::::::::::::\n    \n    // Sum operation handler: X + Y\n    async $add (X, Y, pos) {\n        const xTuple = await X(this);\n        const yTuple = await Y(this);\n        return await mapPairs(xTuple, yTuple, (x, y) => {\n            if (isNothing(x)) return y;\n            if (isNothing(y)) return x;\n            switch (detectPairType(x, y)) {\n                case \"Boolean,Boolean\"    : return x || y;\n                case \"Number,Number\"      : return x + y;\n                case \"String,String\"      : return x + y;\n                case \"List,List\"          : return x.concat(y);\n                case \"Namespace,Namespace\": return Object.assign({}, x, y);\n                default                   : return this.undefined('sum', x, y, pos);\n            }\n        });\n    },\n\n    // Subtraction operation handler: X - Y\n    async $sub (X, Y, pos) {\n        const xTuple = await X(this);\n        const yTuple = await Y(this);\n        return await mapPairs(xTuple, yTuple, (x, y) => {\n            if (isNothing(y)) return x;\n            switch (detectPairType(x, y)) {\n                case \"Number,Number\" : return x - y;\n                default              : return this.undefined('subtraction', x, y, pos);\n            }\n        });\n    },\n\n    // Product operation handler: X * Y\n    async $mul (X, Y, pos) {\n        const xTuple = await X(this);\n        const yTuple = await Y(this);\n        return await mapPairs(xTuple, yTuple, (x, y) => {\n            if (isNothing(x)) return null;\n            if (isNothing(y)) return null;\n            switch (detectPairType(x, y)) {\n                case \"Boolean,Boolean\"    : return x && y;\n                case \"Number,Number\"      : return x * y;\n                case \"Number,String\"      : return x < 0 ? \"\" : y.repeat(x);\n                case \"String,Number\"      : return y < 0 ? \"\" : x.repeat(y);\n                case \"Number,List\"        : return repeatList(y, x);\n                case \"List,Number\"        : return repeatList(x, y);\n                default                   : return this.undefined('product', x, y, pos);\n            }\n        });\n    },\n\n    // Division operation handler: X / Y\n    async $div (X, Y, pos) {\n        const xTuple = await X(this);\n        const yTuple = await Y(this);\n        return await mapPairs(xTuple, yTuple, (x, y) => {\n            if (isNothing(x)) return null;\n            switch (detectPairType(x, y)) {\n                case \"Number,Number\" : return x / y;\n                default              : return this.undefined('division', x, y, pos);\n            }\n        });\n    },\n\n    // Modulo operation handler: X % Y\n    async $mod (X, Y, pos) {\n        const xTuple = await X(this);\n        const yTuple = await Y(this);\n        return await mapPairs(xTuple, yTuple, (x, y) => {\n            if (isNothing(x)) return null;\n            switch (detectPairType(x, y)) {\n                case \"Number,Number\" : return x % y;\n                default              : return this.undefined('modulo', x, y, pos);\n            }\n        });\n    },\n\n    // Exponentiation operation handler: X ^ Y\n    async $pow (X, Y, pos) {\n        const xTuple = await X(this);\n        const yTuple = await Y(this);\n        return await mapPairs(xTuple, yTuple, (x, y) => {\n            if (isNothing(x)) return null;\n            switch (detectPairType(x, y)) {\n                case \"Number,Number\" : return x ** y;\n                default              : return this.undefined('exponentiation', x, y, pos);\n            }\n        });\n    },\n    \n\n    \n    //:::  COMPARISON OPERATION HANDLERS  ::::::::::::::::::::::::::::::::::::::\n\n    // Equal: X == Y\n    async $eq (X, Y) {\n        const x = await X(this);\n        const y = await Y(this);\n        return isSameTuple(x, y);\n    },\n\n    // Not equal: X != Y\n    async $ne (X, Y) {\n        return !(await this.$eq(X, Y));\n    },\n\n    // Less than: X < Y\n    async $lt (X, Y, pos) {\n        const x = await X(this);\n        const y = await Y(this);\n        try {\n            return compareTuples(x, y) < 0;\n        } catch (error) {\n            return this.undefined('comparison', x, y, pos);\n        }\n    },\n\n    // Greater than or equal to: X >= Y\n    async $ge (X, Y, pos) {\n        const x = await X(this);\n        const y = await Y(this);\n        try {\n            return compareTuples(x, y) >= 0;\n        } catch (error) {\n            return this.undefined('comparison', x, y, pos);\n        }\n    },\n\n    // Greater than: X > Y\n    async $gt (X, Y, pos) {\n        const x = await X(this);\n        const y = await Y(this);\n        try {\n            return compareTuples(x, y) > 0;\n        } catch (error) {\n            return this.undefined('comparison', x, y, pos);\n        }\n    },\n\n    // Less than or equal to: X < Y\n    async $le (X, Y, pos) {\n        const x = await X(this);\n        const y = await Y(this);\n        try {\n            return compareTuples(x, y) <= 0;\n        } catch (error) {\n            return this.undefined('comparison', x, y, pos);\n        }\n    },\n    \n\n\n    //:::  FUNCTION COMPOSITION  :::::::::::::::::::::::::::::::::::::::::::::::\n    \n    // Function composition operation handler: G << F\n    $compose (G, F) {\n        return (...args) => this.$apply(G, () => this.$apply(F, () => Tuple(...args)));\n    },\n    \n    // Function piping operation handler: F >> G\n    $pipe (F, G) {\n        return this.$compose(G, F);\n    },\n    \n    \n    \n    //:::  BUILT-IN CONSTANTS  :::::::::::::::::::::::::::::::::::::::::::::::::\n    \n    TRUE    : true,\n    FALSE   : false,\n    INFINITY: Infinity,\n\n\n\n    //::: BUILT-IN FUNCTIONS  ::::::::::::::::::::::::::::::::::::::::::::::::::\n    \n    // Returns an Undefined instance\n    undefined (...args) {\n        return new Undefined(...args);\n    },\n\n    // Converts a tuple to boolean\n    bool (...items) {\n        for (let item of Tuple(...items)) {\n            if (item instanceof Undefined) {\n                return this.undefined('booleanization', item);\n            }\n            if (convertItemToBoolean(item) !== false) return true;\n        }\n        return false;\n    },\n    \n    // Returns NOT bool(X)\n    not (...items) {\n        const bool = this.bool(...items);\n        return bool instanceof Undefined ? bool : !bool;\n    },\n    \n    // Converts a tuple to string\n    str (...items) {\n        return Array.from(Tuple(...items)).map(\n            item => this[`$stringify${detectItemType(item)}`](item)\n        ).join(\"\");\n    },\n    \n    $stringifyBoolean   : item => item ? \"TRUE\" : \"FALSE\",\n    $stringifyNumber    : item => String(item),\n    $stringifyFunction  : item => \"[[Function]]\",\n    $stringifyString    : item => item,\n    $stringifyList      : item => `[[List of ${item.length} items]]`,\n    $stringifyNamespace : item => isString(item.__str__) ? item.__str__ : `[[Namespace of ${countNamespaceNames(item)} items]]`,\n    $stringifyUndefined (item) {\n        const argstr = item.args.mapSync(arg => {\n            if (arg instanceof Error) {\n                return `[[Error: ${arg.message}]]`\n            } else if (arg instanceof Parser.Position) {\n                return String(arg);\n            } else {\n                return this[`$stringify${detectItemType(arg)}`](arg);\n            }\n        });\n        return `[[Undefined: ${Array.from(argstr).join(', ')}]]`;\n    },\n    \n    // Enumerates an enumerable item\n    enum (...items) {\n        return Tuple(...items).mapAsync(async item => {\n            \n            switch (detectItemType(item)) {\n                case \"Number\"   : return Tuple(...aritmeticSequence1(item));\n                case \"String\"   : return Tuple(...item);\n                case \"List\"     : return Tuple(...item);\n                case \"Namespace\": return Tuple(...listNamespaceNames(item));\n                default         : return this.undefined('enumeration', item);\n            }\n            \n        }).then(tuple => tuple.normalize());\n    },\n    \n    // Returns the type names of a tuble\n    type (...items) {\n        return Tuple(...items).mapSync(detectItemType).normalize();\n    },\n    \n    // Returns the number of item of a container (String, List or Namespace)\n    size (...items) {\n        return Tuple(...items).mapSync(item => {\n            \n            switch (detectItemType(item)) {\n                case \"String\"   : return item.length;\n                case \"List\"     : return item.length;\n                case \"Namespace\": return countNamespaceNames(item);\n                default         : return this.undefined('size', item);\n            }\n            \n        }).normalize();\n    },\n    \n    \n    \n    //:::  CONTEXT PROPERTIES  :::::::::::::::::::::::::::::::::::::::::::::::::\n    \n    // Expose the swan custom types to javascript\n    $Tuple: Tuple,\n    $Undefined: Undefined,\n    \n    // Extends the current context with new names\n    $extend (namespace={}) {\n        const context = Object.create(this);\n        for (let name in namespace) {\n            context[name] = namespace[name];\n        }\n        return context;\n    }\n};\n\n\n\n\n\n// -----------------------------------------------------------------------------\n//  EXPORTS\n// -----------------------------------------------------------------------------\n\nmodule.exports = {Tuple, Undefined, parse, context};\n\n//# sourceURL=webpack:///./node_modules/@onlabsorg/swan-js/lib/interpreter.js?");

/***/ }),

/***/ "./node_modules/@onlabsorg/swan-js/lib/lexer.js":
/*!******************************************************!*\
  !*** ./node_modules/@onlabsorg/swan-js/lib/lexer.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("\nclass Lexer {\n    \n    constructor (options) {\n        this.binaryOperators = new Set(options.binaryOperators);\n        this.unaryOperators = new Set(options.unaryOperators);\n        \n        const isSymbol = operator => !this.matchIdentifierStart(operator);\n        this.SYMBOLS = new Set( ['{', '[', '(', ')', ']', '}']\n                .concat(options.binaryOperators.filter(isSymbol)) \n                .concat(options.unaryOperators.filter(isSymbol)));\n    }\n\n    matchSpace           (char) { return char && char.match(/^\\s$/)           }\n    matchQuote           (char) { return char && char.match(/^[\"'`]$/)        }\n    matchIdentifierStart (char) { return char && char.match(/^[a-z_A-Z]$/)    }\n    matchIdentifierPart  (char) { return char && char.match(/^[a-z_A-Z0-9]$/) }\n    matchDecimalDigit    (char) { return char && char.match(/^[0-9]$/)        }\n    matchSign            (char) { return char === \"+\" || char === \"-\"         }\n    matchCommentStart    (sym)  { return sym === \"#\"                          }\n    matchSymbol          (sym)  { return this.SYMBOLS.has(sym)                }\n    \n    * tokenize (source) {\n        \n        const createToken = (type, value, index) => \n                new this.constructor.Token(this, type, value, new this.constructor.Position(source, index));\n                \n        const createSyntaxError = (message, index) => \n                new this.constructor.SyntaxError(message, source, index);\n        \n        var i = 0, len = source.length;\n        while (true) {\n            while (this.matchSpace(source[i])) i++;\n            if (i >= len) break;\n\n            // if string literal\n            if (this.matchQuote(source[i])) {\n                let value = \"\";            \n                let quoteSymbol = source[i]; i++;\n                while (source[i] !== quoteSymbol) {\n                    if (i >= len) throw createSyntaxError(\"Closing quote expected\", i);\n                    value += source[i]; i++;\n                }\n                let token = createToken(Token.STRING, value, i);\n                token.quoteSymbol = quoteSymbol;\n                yield token; i++;\n            }\n            \n            // if identifier\n            else if (this.matchIdentifierStart(source[i])) {\n                let value = source[i]; i++;\n                while (this.matchIdentifierPart(source[i])) {\n                    value += source[i]; i++;\n                }\n                yield createToken(Token.IDENTIFIER, value, i);\n            }\n\n            // if number literal\n            else if (this.matchDecimalDigit(source[i])) {\n                let numStr = source[i]; i++;\n                \n                while (this.matchDecimalDigit(source[i])) {\n                    numStr += source[i]; i++;\n                }\n\n                if (source[i] === \".\") {\n                    numStr += source[i]; i++;\n                    while (this.matchDecimalDigit(source[i])) {\n                        numStr += source[i]; i++;\n                    }        \n                }\n                \n                if (source[i] === 'e' || source[i] === 'E') {\n                    numStr += 'E'; i++;\n                    if (source[i] === '+' || source[i] === '-') { // exponent sign\n                        numStr += source[i]; i++;\n                    }\n                    if (!this.matchDecimalDigit(source[i])) {\n                        throw createSyntaxError(`Expected exponent value`, i);                    \n                    }\n                    numStr += source[i]; i++;\n                    while (this.matchDecimalDigit(source[i])) {\n                        numStr += source[i]; i++;\n                    }        \n                }\n                \n                if (this.matchIdentifierStart(source[i])) {\n                    throw createSyntaxError(`Invalid number`, i-1);\n                } else if (source[i] === \".\") {\n                    throw createSyntaxError('Unexpected period', i);\n                }\n\n                yield createToken(Token.NUMBER, Number(numStr), i);\n            }\n            \n            else if (this.matchCommentStart(source[i])) {\n                i++; while (source[i] !== \"\\n\" && i < len) i++;\n            }\n            \n            else if (this.matchSymbol( source[i]+source[i+1] )) {\n                yield createToken(Token.SYMBOL, source[i]+source[i+1], i); i+=2;\n            } \n            \n            else if (this.matchSymbol( source[i] )) {\n                yield createToken(Token.SYMBOL, source[i], i); i++;\n            } \n\n            else {\n                throw createSyntaxError(`Unexpected character '${source[i]}'`, i);\n            }\n        }        \n    }\n    \n    static get Position    () { return Position    }\n    static get SyntaxError () { return SyntaxError }\n    static get Token       () { return Token       }\n}\n\n\n\nclass Token {\n    \n    constructor (lexer, type, value, pos) {\n        this.lexer = lexer;\n        this.type = type;\n        this.value = value;\n        this.position = pos;\n    }    \n    \n    matchSymbol (sym) {\n        return this.type === Token.SYMBOL && this.value === sym;\n    }\n    \n    matchSign () {\n        return this.matchSymbol(\"+\") || this.matchSymbol(\"-\");\n    }\n    \n    matchIdentifier () {\n        return this.type === Token.IDENTIFIER && !this.lexer.binaryOperators.has(this.value);\n    }\n    \n    matchBinaryOperator () {\n        return (this.type === Token.SYMBOL || this.type === Token.IDENTIFIER) && \n                this.lexer.binaryOperators.has(this.value);\n    }\n    \n    matchUnaryOperator () {\n        return (this.type === Token.SYMBOL || this.type === Token.IDENTIFIER) && \n                this.lexer.unaryOperators.has(this.value);\n    }\n\n    matchOpenBracket () {\n        return this.matchSymbol('(') || this.matchSymbol('[');\n    }\n    \n    matchNumberLiteral () {\n        return this.type === Token.NUMBER;\n    }\n    \n    matchStringLiteral () {\n        return this.type === Token.STRING;\n    }\n\n    matchLiteral () {\n        return this.type === Token.NUMBER || this.type === Token.STRING;\n    }\n}\n\n// Token types\nToken.SYMBOL = 0;\nToken.NUMBER = 1;\nToken.STRING = 2;\nToken.IDENTIFIER = 3;\n\n\n\nclass Position {\n\n    constructor (source, index) {\n        this.source = source;\n        this.index = index;\n    }\n    \n    getLocation () {\n        const lines = this.source.slice(0, this.index).split('\\n');\n        const row = lines.length;\n        const col = lines.pop().length;\n        return [row, col];\n    }\n    \n    toString () {\n        const [row, col] = this.getLocation();\n        return `@${row}:${col}`;\n    }    \n}\n\n\n\nclass SyntaxError extends Error {\n    \n    constructor (message, source, index) {\n        const position = new Position(source, index);\n        super(`${message} ${position}`);\n        this.position = position;\n    }\n}\n\n\n\nmodule.exports = Lexer;\n\n\n//# sourceURL=webpack:///./node_modules/@onlabsorg/swan-js/lib/lexer.js?");

/***/ }),

/***/ "./node_modules/@onlabsorg/swan-js/lib/modules.js":
/*!********************************************************!*\
  !*** ./node_modules/@onlabsorg/swan-js/lib/modules.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const pathlib = __webpack_require__(/*! path */ \"./node_modules/node-libs-browser/node_modules/path-browserify/index.js\");\n\nfunction normPath (path) {\n    return pathlib.normalize(`/${path}`);\n}\n\n\n\nconst modules = {};\n\nexports.require = async function (modulePath) {\n    const module = await modules[normPath(modulePath)]();\n    return module.default || module;\n}\n\nconst define = exports.define = function (modulePath, load) {\n    modules[normPath(modulePath)] = load;\n}\n\ndefine(\"date\"     , () => __webpack_require__.e(/*! import() | swan_modules/date */ \"swan_modules/date\").then(__webpack_require__.t.bind(null, /*! ./modules/date.js */ \"./node_modules/@onlabsorg/swan-js/lib/modules/date.js\", 7)));\ndefine(\"http\"     , () => __webpack_require__.e(/*! import() | swan_modules/http */ \"swan_modules/http\").then(__webpack_require__.t.bind(null, /*! ./modules/http.js */ \"./node_modules/@onlabsorg/swan-js/lib/modules/http.js\", 7)));\ndefine(\"json\"     , () => __webpack_require__.e(/*! import() | swan_modules/json */ \"swan_modules/json\").then(__webpack_require__.t.bind(null, /*! ./modules/json.js */ \"./node_modules/@onlabsorg/swan-js/lib/modules/json.js\", 7)));\ndefine(\"list\"     , () => __webpack_require__.e(/*! import() | swan_modules/list */ \"swan_modules/list\").then(__webpack_require__.t.bind(null, /*! ./modules/list.js */ \"./node_modules/@onlabsorg/swan-js/lib/modules/list.js\", 7)));\ndefine(\"math\"     , () => __webpack_require__.e(/*! import() | swan_modules/math */ \"swan_modules/math\").then(__webpack_require__.t.bind(null, /*! ./modules/math.js */ \"./node_modules/@onlabsorg/swan-js/lib/modules/math.js\", 7)));\ndefine(\"path\"     , () => __webpack_require__.e(/*! import() | swan_modules/path */ \"swan_modules/path\").then(__webpack_require__.t.bind(null, /*! ./modules/path.js */ \"./node_modules/@onlabsorg/swan-js/lib/modules/path.js\", 7)));\ndefine(\"text\"     , () => __webpack_require__.e(/*! import() | swan_modules/text */ \"swan_modules/text\").then(__webpack_require__.t.bind(null, /*! ./modules/text.js */ \"./node_modules/@onlabsorg/swan-js/lib/modules/text.js\", 7)));\ndefine(\"debug\"    , () => __webpack_require__.e(/*! import() | swan_modules/debug */ \"swan_modules/debug\").then(__webpack_require__.t.bind(null, /*! ./modules/debug.js */ \"./node_modules/@onlabsorg/swan-js/lib/modules/debug.js\", 7)));\n\n\n\n//# sourceURL=webpack:///./node_modules/@onlabsorg/swan-js/lib/modules.js?");

/***/ }),

/***/ "./node_modules/@onlabsorg/swan-js/lib/parser.js":
/*!*******************************************************!*\
  !*** ./node_modules/@onlabsorg/swan-js/lib/parser.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("//  The main export of this module creates and returns a `parse` function,\n//  given a set of syntax options.\n//  \n//  The `parse` function takes an expression string as input and returns an\n//  `evaluate` function.\n//\n//  The `evaluate` function takes an evaluation context as input and returns\n//  the expression value as output.\n\nconst Lexer = __webpack_require__(/*! ./lexer */ \"./node_modules/@onlabsorg/swan-js/lib/lexer.js\");\n\n\n\nclass Parser {\n    \n    constructor (options) {\n        this.options = options;\n        \n        // create the lexer, given the list of the valid operators\n        this.lexer = new Lexer({\n            binaryOperators: Object.keys(options.binaryOperations),\n            unaryOperators: Object.keys(options.unaryOperations)\n        });\n    }\n    \n    tokenize (source) {\n        return new Tokens(...this.lexer.tokenize(source));\n    }\n    \n    // The `createOperation` funcction returns a function that, once called\n    // with a `context` object, executes an operation and return its value.\n    // Each operation is a node of the AST generated by this parser: each\n    // operand of the operation is in turn either another operation or\n    // a value (leaf).\n    createOperation (handlerName, operands, position) {\n        return async context => {\n            try {\n                if (typeof context[handlerName] !== \"function\") {\n                    throw new Error(`'${handlerName}' handler not defined in this context`);\n                }                \n                return await context[handlerName](...operands, position);\n                \n            } catch (error) {\n                return await context[this.options.errorHandler](error, position);\n            }\n        }\n    }\n    \n    createSyntaxError (message, token) {\n        return new Lexer.SyntaxError(message, token.position.source, token.position.index);\n    }\n    \n    // The following tuns turns the next tokens into a single Operation tree.\n    // It stops when the passed `done` condition is true\n    parseExpression (tokens, done) {\n        \n        // If the `done` condition is immediately true, than the expression\n        // is empty and the `void` operation is returned.\n        if (done()) {\n            const lastToken = tokens.get() || tokens.last || tokens.tail;\n            tokens.inc(); return this.createOperation(this.options.voidHandler, [], lastToken.position);\n        }\n        \n        // First generates an `expression` list [operand, operator, operand, operator, ...].\n        // Then sorts the operators by precedence and returns a function.\n        \n        // Initialize the `epression` list with the first operand.\n        var expression = [ this.parseOperand(tokens) ];\n        \n        // Iterate over all the other operators and operands and add them\n        // to the `expression` list until the `done` condition is matched.\n        while (!done()) {\n            \n            if (tokens.get() && tokens.get().matchBinaryOperator()) {\n                let operator = Object.create(this.options.binaryOperations[tokens.get().value]);\n                operator.position = tokens.get().position;\n                tokens.inc(); \n                expression.push(operator);                \n                if (done()) {\n                    throw this.createSyntaxError('Operand expected', tokens.get() || tokens.tail);\n                }\n                let operand = this.parseOperand(tokens);\n                expression.push(operand);\n            }\n            else {\n                // if the next token is not an operator, then an empty operator\n                // is assumed. This means that the expression consists of \n                // two operands next to each other, without any interposed\n                // operator.\n                let operator = Object.create(this.options.binaryOperations[\"\"]);\n                operator.position = tokens.get(-1).position;\n                expression.push(operator);\n                let operand = this.parseOperand(tokens);\n                expression.push(operand);\n            }\n        }\n        tokens.inc();\n        \n        // Build the operations tree from the plain list [operand, operator, operand, ...]\n        while (expression.length > 1) {\n            \n            // find higher precedence operand\n            let precedence = 0;\n            let operatorIndex = 0;\n            for (let j=1; j<expression.length; j+=2) {\n                let operator = expression[j];\n                if (operator.precedence > precedence) {\n                    if (operator.right) {\n                        let handler = operator.handler;\n                        while (expression[j+2] && expression[j+2].handler === handler) j += 2;\n                    }\n                    precedence = operator.precedence;\n                    operatorIndex = j;\n                }\n            }\n            \n            // evaluate the higher precedence operation\n            let leftHandOperand = expression[operatorIndex - 1];\n            let operator = expression[operatorIndex];\n            let rightHandOperand = expression[operatorIndex + 1];\n            let operation = this.createOperation(operator.handler, [leftHandOperand, rightHandOperand], operator.position);\n            \n            // replace the [...,left,operator,right,...] items with the operation node\n            expression.splice(operatorIndex-1, 3, operation);\n        }\n        \n        // Returns the root operation\n        return expression[0];                \n    }\n    \n    // Returns the next operand in line.\n    // An operand can be a value (leaf) or an branch of the operation tree.\n    parseOperand (tokens) {\n        var unaryOperator, operand;\n        \n        // If the operand is preceded by a unary operator\n        if (tokens.get() && tokens.get().matchUnaryOperator()) {\n            unaryOperator = tokens.get(); \n            tokens.inc();\n        }\n        \n        // If just a number literal\n        if (tokens.get() && tokens.get().matchNumberLiteral()) {\n            operand = this.createOperation(this.options.numberHandler, [tokens.get().value], tokens.get().position); tokens.inc();\n        }\n        \n        // If a string literal\n        else if (tokens.get() && tokens.get().matchStringLiteral()) {\n            if (tokens.get().quoteSymbol === `'`) operand = this.createOperation(this.options.stringHandler1, [tokens.get().value], tokens.get().position);\n            else if (tokens.get().quoteSymbol === `\"`) operand = this.createOperation(this.options.stringHandler2, [tokens.get().value], tokens.get().position);\n            else if (tokens.get().quoteSymbol === '`') operand = this.createOperation(this.options.stringHandler3, [tokens.get().value], tokens.get().position);\n            tokens.inc();\n        }\n        \n        // If an identifier\n        else if (tokens.get() && tokens.get().matchIdentifier()) {\n            operand = this.createOperation(this.options.nameHandler, [tokens.get().value], tokens.get().position); tokens.inc();            \n        }\n        \n        // If a subexpression between `(` and `)`\n        else if (tokens.get() && tokens.get().matchSymbol('(')) {\n            tokens.inc(); operand = this.parseExpression(tokens,  () => tokens.get() && tokens.get().matchSymbol(\")\") );\n        }\n        \n        // If a subexpression between `[` and `]`\n        else if (tokens.get() && tokens.get().matchSymbol('[')) {\n            const position = tokens.get().position; tokens.inc();\n            let expression = this.parseExpression(tokens,  () => tokens.get() && tokens.get().matchSymbol(\"]\") );\n            operand = this.createOperation(this.options.squareGroupHandler, [expression], position);\n        }\n        \n        // If a subexpression between `{` and `}`\n        else if (tokens.get() && tokens.get().matchSymbol('{')) {\n            const position = tokens.get().position; tokens.inc();\n            let expression = this.parseExpression(tokens,  () => tokens.get() && tokens.get().matchSymbol(\"}\") );\n            operand = this.createOperation(this.options.curlyGroupHandler, [expression], position);\n        }\n        \n        // No valid operand found\n        else {\n            throw this.createSyntaxError('Operand expected', tokens.get() || tokens.tail);\n        }\n        \n        if (unaryOperator) {\n            const handler = this.options.unaryOperations[unaryOperator.value];\n            return this.createOperation(handler, [operand], unaryOperator.position);\n        } else {\n            return operand;\n        }\n    }    \n    \n    \n    parse (source) {\n        try {\n            // Perform the lexical analysis\n            var tokens = this.tokenize(source);    // array of tokens\n            tokens.tail = {position: new Lexer.Position(source, source.length)};\n            \n            // Parse the entier expression and return the `evaluate` function\n            return this.parseExpression(tokens, () => tokens.done() );\n            \n        } catch (error) {\n            return async context => await context[this.options.errorHandler](error);\n        }        \n    }\n    \n    static get Position () {\n        return Lexer.Position;\n    }\n}\n\n\n\nclass Tokens {\n    \n    constructor (...tokens) {\n        this.tokens = tokens;\n        this.index = 0;\n    }\n    \n    inc (step=1) {\n        this.index += step;\n        return this;\n    }\n    \n    get (step=0) {\n        return this.tokens[this.index+step];\n    }\n    \n    get last () {\n        return this.tokens[this.tokens.length-1];\n    }\n    \n    done () {\n        return this.index >= this.tokens.length;\n    }\n}\n\n\n\nmodule.exports = Parser;\n\n\n//# sourceURL=webpack:///./node_modules/@onlabsorg/swan-js/lib/parser.js?");

/***/ }),

/***/ "./node_modules/dompurify/dist/purify.js":
/*!***********************************************!*\
  !*** ./node_modules/dompurify/dist/purify.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*! @license DOMPurify | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/2.2.2/LICENSE */\n\n(function (global, factory) {\n   true ? module.exports = factory() :\n  undefined;\n}(this, function () { 'use strict';\n\n  function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\n  var hasOwnProperty = Object.hasOwnProperty,\n      setPrototypeOf = Object.setPrototypeOf,\n      isFrozen = Object.isFrozen,\n      getPrototypeOf = Object.getPrototypeOf,\n      getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n  var freeze = Object.freeze,\n      seal = Object.seal,\n      create = Object.create; // eslint-disable-line import/no-mutable-exports\n\n  var _ref = typeof Reflect !== 'undefined' && Reflect,\n      apply = _ref.apply,\n      construct = _ref.construct;\n\n  if (!apply) {\n    apply = function apply(fun, thisValue, args) {\n      return fun.apply(thisValue, args);\n    };\n  }\n\n  if (!freeze) {\n    freeze = function freeze(x) {\n      return x;\n    };\n  }\n\n  if (!seal) {\n    seal = function seal(x) {\n      return x;\n    };\n  }\n\n  if (!construct) {\n    construct = function construct(Func, args) {\n      return new (Function.prototype.bind.apply(Func, [null].concat(_toConsumableArray(args))))();\n    };\n  }\n\n  var arrayForEach = unapply(Array.prototype.forEach);\n  var arrayPop = unapply(Array.prototype.pop);\n  var arrayPush = unapply(Array.prototype.push);\n\n  var stringToLowerCase = unapply(String.prototype.toLowerCase);\n  var stringMatch = unapply(String.prototype.match);\n  var stringReplace = unapply(String.prototype.replace);\n  var stringIndexOf = unapply(String.prototype.indexOf);\n  var stringTrim = unapply(String.prototype.trim);\n\n  var regExpTest = unapply(RegExp.prototype.test);\n\n  var typeErrorCreate = unconstruct(TypeError);\n\n  function unapply(func) {\n    return function (thisArg) {\n      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      return apply(func, thisArg, args);\n    };\n  }\n\n  function unconstruct(func) {\n    return function () {\n      for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      return construct(func, args);\n    };\n  }\n\n  /* Add properties to a lookup table */\n  function addToSet(set, array) {\n    if (setPrototypeOf) {\n      // Make 'in' and truthy checks like Boolean(set.constructor)\n      // independent of any properties defined on Object.prototype.\n      // Prevent prototype setters from intercepting set as a this value.\n      setPrototypeOf(set, null);\n    }\n\n    var l = array.length;\n    while (l--) {\n      var element = array[l];\n      if (typeof element === 'string') {\n        var lcElement = stringToLowerCase(element);\n        if (lcElement !== element) {\n          // Config presets (e.g. tags.js, attrs.js) are immutable.\n          if (!isFrozen(array)) {\n            array[l] = lcElement;\n          }\n\n          element = lcElement;\n        }\n      }\n\n      set[element] = true;\n    }\n\n    return set;\n  }\n\n  /* Shallow clone an object */\n  function clone(object) {\n    var newObject = create(null);\n\n    var property = void 0;\n    for (property in object) {\n      if (apply(hasOwnProperty, object, [property])) {\n        newObject[property] = object[property];\n      }\n    }\n\n    return newObject;\n  }\n\n  /* IE10 doesn't support __lookupGetter__ so lets'\n   * simulate it. It also automatically checks\n   * if the prop is function or getter and behaves\n   * accordingly. */\n  function lookupGetter(object, prop) {\n    while (object !== null) {\n      var desc = getOwnPropertyDescriptor(object, prop);\n      if (desc) {\n        if (desc.get) {\n          return unapply(desc.get);\n        }\n\n        if (typeof desc.value === 'function') {\n          return unapply(desc.value);\n        }\n      }\n\n      object = getPrototypeOf(object);\n    }\n\n    function fallbackValue(element) {\n      console.warn('fallback value for', element);\n      return null;\n    }\n\n    return fallbackValue;\n  }\n\n  var html = freeze(['a', 'abbr', 'acronym', 'address', 'area', 'article', 'aside', 'audio', 'b', 'bdi', 'bdo', 'big', 'blink', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'center', 'cite', 'code', 'col', 'colgroup', 'content', 'data', 'datalist', 'dd', 'decorator', 'del', 'details', 'dfn', 'dialog', 'dir', 'div', 'dl', 'dt', 'element', 'em', 'fieldset', 'figcaption', 'figure', 'font', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'i', 'img', 'input', 'ins', 'kbd', 'label', 'legend', 'li', 'main', 'map', 'mark', 'marquee', 'menu', 'menuitem', 'meter', 'nav', 'nobr', 'ol', 'optgroup', 'option', 'output', 'p', 'picture', 'pre', 'progress', 'q', 'rp', 'rt', 'ruby', 's', 'samp', 'section', 'select', 'shadow', 'small', 'source', 'spacer', 'span', 'strike', 'strong', 'style', 'sub', 'summary', 'sup', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'time', 'tr', 'track', 'tt', 'u', 'ul', 'var', 'video', 'wbr']);\n\n  // SVG\n  var svg = freeze(['svg', 'a', 'altglyph', 'altglyphdef', 'altglyphitem', 'animatecolor', 'animatemotion', 'animatetransform', 'circle', 'clippath', 'defs', 'desc', 'ellipse', 'filter', 'font', 'g', 'glyph', 'glyphref', 'hkern', 'image', 'line', 'lineargradient', 'marker', 'mask', 'metadata', 'mpath', 'path', 'pattern', 'polygon', 'polyline', 'radialgradient', 'rect', 'stop', 'style', 'switch', 'symbol', 'text', 'textpath', 'title', 'tref', 'tspan', 'view', 'vkern']);\n\n  var svgFilters = freeze(['feBlend', 'feColorMatrix', 'feComponentTransfer', 'feComposite', 'feConvolveMatrix', 'feDiffuseLighting', 'feDisplacementMap', 'feDistantLight', 'feFlood', 'feFuncA', 'feFuncB', 'feFuncG', 'feFuncR', 'feGaussianBlur', 'feMerge', 'feMergeNode', 'feMorphology', 'feOffset', 'fePointLight', 'feSpecularLighting', 'feSpotLight', 'feTile', 'feTurbulence']);\n\n  // List of SVG elements that are disallowed by default.\n  // We still need to know them so that we can do namespace\n  // checks properly in case one wants to add them to\n  // allow-list.\n  var svgDisallowed = freeze(['animate', 'color-profile', 'cursor', 'discard', 'fedropshadow', 'feimage', 'font-face', 'font-face-format', 'font-face-name', 'font-face-src', 'font-face-uri', 'foreignobject', 'hatch', 'hatchpath', 'mesh', 'meshgradient', 'meshpatch', 'meshrow', 'missing-glyph', 'script', 'set', 'solidcolor', 'unknown', 'use']);\n\n  var mathMl = freeze(['math', 'menclose', 'merror', 'mfenced', 'mfrac', 'mglyph', 'mi', 'mlabeledtr', 'mmultiscripts', 'mn', 'mo', 'mover', 'mpadded', 'mphantom', 'mroot', 'mrow', 'ms', 'mspace', 'msqrt', 'mstyle', 'msub', 'msup', 'msubsup', 'mtable', 'mtd', 'mtext', 'mtr', 'munder', 'munderover']);\n\n  // Similarly to SVG, we want to know all MathML elements,\n  // even those that we disallow by default.\n  var mathMlDisallowed = freeze(['maction', 'maligngroup', 'malignmark', 'mlongdiv', 'mscarries', 'mscarry', 'msgroup', 'mstack', 'msline', 'msrow', 'semantics', 'annotation', 'annotation-xml', 'mprescripts', 'none']);\n\n  var text = freeze(['#text']);\n\n  var html$1 = freeze(['accept', 'action', 'align', 'alt', 'autocapitalize', 'autocomplete', 'autopictureinpicture', 'autoplay', 'background', 'bgcolor', 'border', 'capture', 'cellpadding', 'cellspacing', 'checked', 'cite', 'class', 'clear', 'color', 'cols', 'colspan', 'controls', 'controlslist', 'coords', 'crossorigin', 'datetime', 'decoding', 'default', 'dir', 'disabled', 'disablepictureinpicture', 'disableremoteplayback', 'download', 'draggable', 'enctype', 'enterkeyhint', 'face', 'for', 'headers', 'height', 'hidden', 'high', 'href', 'hreflang', 'id', 'inputmode', 'integrity', 'ismap', 'kind', 'label', 'lang', 'list', 'loading', 'loop', 'low', 'max', 'maxlength', 'media', 'method', 'min', 'minlength', 'multiple', 'muted', 'name', 'noshade', 'novalidate', 'nowrap', 'open', 'optimum', 'pattern', 'placeholder', 'playsinline', 'poster', 'preload', 'pubdate', 'radiogroup', 'readonly', 'rel', 'required', 'rev', 'reversed', 'role', 'rows', 'rowspan', 'spellcheck', 'scope', 'selected', 'shape', 'size', 'sizes', 'span', 'srclang', 'start', 'src', 'srcset', 'step', 'style', 'summary', 'tabindex', 'title', 'translate', 'type', 'usemap', 'valign', 'value', 'width', 'xmlns', 'slot']);\n\n  var svg$1 = freeze(['accent-height', 'accumulate', 'additive', 'alignment-baseline', 'ascent', 'attributename', 'attributetype', 'azimuth', 'basefrequency', 'baseline-shift', 'begin', 'bias', 'by', 'class', 'clip', 'clippathunits', 'clip-path', 'clip-rule', 'color', 'color-interpolation', 'color-interpolation-filters', 'color-profile', 'color-rendering', 'cx', 'cy', 'd', 'dx', 'dy', 'diffuseconstant', 'direction', 'display', 'divisor', 'dur', 'edgemode', 'elevation', 'end', 'fill', 'fill-opacity', 'fill-rule', 'filter', 'filterunits', 'flood-color', 'flood-opacity', 'font-family', 'font-size', 'font-size-adjust', 'font-stretch', 'font-style', 'font-variant', 'font-weight', 'fx', 'fy', 'g1', 'g2', 'glyph-name', 'glyphref', 'gradientunits', 'gradienttransform', 'height', 'href', 'id', 'image-rendering', 'in', 'in2', 'k', 'k1', 'k2', 'k3', 'k4', 'kerning', 'keypoints', 'keysplines', 'keytimes', 'lang', 'lengthadjust', 'letter-spacing', 'kernelmatrix', 'kernelunitlength', 'lighting-color', 'local', 'marker-end', 'marker-mid', 'marker-start', 'markerheight', 'markerunits', 'markerwidth', 'maskcontentunits', 'maskunits', 'max', 'mask', 'media', 'method', 'mode', 'min', 'name', 'numoctaves', 'offset', 'operator', 'opacity', 'order', 'orient', 'orientation', 'origin', 'overflow', 'paint-order', 'path', 'pathlength', 'patterncontentunits', 'patterntransform', 'patternunits', 'points', 'preservealpha', 'preserveaspectratio', 'primitiveunits', 'r', 'rx', 'ry', 'radius', 'refx', 'refy', 'repeatcount', 'repeatdur', 'restart', 'result', 'rotate', 'scale', 'seed', 'shape-rendering', 'specularconstant', 'specularexponent', 'spreadmethod', 'startoffset', 'stddeviation', 'stitchtiles', 'stop-color', 'stop-opacity', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity', 'stroke', 'stroke-width', 'style', 'surfacescale', 'systemlanguage', 'tabindex', 'targetx', 'targety', 'transform', 'text-anchor', 'text-decoration', 'text-rendering', 'textlength', 'type', 'u1', 'u2', 'unicode', 'values', 'viewbox', 'visibility', 'version', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'width', 'word-spacing', 'wrap', 'writing-mode', 'xchannelselector', 'ychannelselector', 'x', 'x1', 'x2', 'xmlns', 'y', 'y1', 'y2', 'z', 'zoomandpan']);\n\n  var mathMl$1 = freeze(['accent', 'accentunder', 'align', 'bevelled', 'close', 'columnsalign', 'columnlines', 'columnspan', 'denomalign', 'depth', 'dir', 'display', 'displaystyle', 'encoding', 'fence', 'frame', 'height', 'href', 'id', 'largeop', 'length', 'linethickness', 'lspace', 'lquote', 'mathbackground', 'mathcolor', 'mathsize', 'mathvariant', 'maxsize', 'minsize', 'movablelimits', 'notation', 'numalign', 'open', 'rowalign', 'rowlines', 'rowspacing', 'rowspan', 'rspace', 'rquote', 'scriptlevel', 'scriptminsize', 'scriptsizemultiplier', 'selection', 'separator', 'separators', 'stretchy', 'subscriptshift', 'supscriptshift', 'symmetric', 'voffset', 'width', 'xmlns']);\n\n  var xml = freeze(['xlink:href', 'xml:id', 'xlink:title', 'xml:space', 'xmlns:xlink']);\n\n  // eslint-disable-next-line unicorn/better-regex\n  var MUSTACHE_EXPR = seal(/\\{\\{[\\s\\S]*|[\\s\\S]*\\}\\}/gm); // Specify template detection regex for SAFE_FOR_TEMPLATES mode\n  var ERB_EXPR = seal(/<%[\\s\\S]*|[\\s\\S]*%>/gm);\n  var DATA_ATTR = seal(/^data-[\\-\\w.\\u00B7-\\uFFFF]/); // eslint-disable-line no-useless-escape\n  var ARIA_ATTR = seal(/^aria-[\\-\\w]+$/); // eslint-disable-line no-useless-escape\n  var IS_ALLOWED_URI = seal(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\\-]+(?:[^a-z+.\\-:]|$))/i // eslint-disable-line no-useless-escape\n  );\n  var IS_SCRIPT_OR_DATA = seal(/^(?:\\w+script|data):/i);\n  var ATTR_WHITESPACE = seal(/[\\u0000-\\u0020\\u00A0\\u1680\\u180E\\u2000-\\u2029\\u205F\\u3000]/g // eslint-disable-line no-control-regex\n  );\n\n  var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n  function _toConsumableArray$1(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\n  var getGlobal = function getGlobal() {\n    return typeof window === 'undefined' ? null : window;\n  };\n\n  /**\n   * Creates a no-op policy for internal use only.\n   * Don't export this function outside this module!\n   * @param {?TrustedTypePolicyFactory} trustedTypes The policy factory.\n   * @param {Document} document The document object (to determine policy name suffix)\n   * @return {?TrustedTypePolicy} The policy created (or null, if Trusted Types\n   * are not supported).\n   */\n  var _createTrustedTypesPolicy = function _createTrustedTypesPolicy(trustedTypes, document) {\n    if ((typeof trustedTypes === 'undefined' ? 'undefined' : _typeof(trustedTypes)) !== 'object' || typeof trustedTypes.createPolicy !== 'function') {\n      return null;\n    }\n\n    // Allow the callers to control the unique policy name\n    // by adding a data-tt-policy-suffix to the script element with the DOMPurify.\n    // Policy creation with duplicate names throws in Trusted Types.\n    var suffix = null;\n    var ATTR_NAME = 'data-tt-policy-suffix';\n    if (document.currentScript && document.currentScript.hasAttribute(ATTR_NAME)) {\n      suffix = document.currentScript.getAttribute(ATTR_NAME);\n    }\n\n    var policyName = 'dompurify' + (suffix ? '#' + suffix : '');\n\n    try {\n      return trustedTypes.createPolicy(policyName, {\n        createHTML: function createHTML(html$$1) {\n          return html$$1;\n        }\n      });\n    } catch (_) {\n      // Policy creation failed (most likely another DOMPurify script has\n      // already run). Skip creating the policy, as this will only cause errors\n      // if TT are enforced.\n      console.warn('TrustedTypes policy ' + policyName + ' could not be created.');\n      return null;\n    }\n  };\n\n  function createDOMPurify() {\n    var window = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getGlobal();\n\n    var DOMPurify = function DOMPurify(root) {\n      return createDOMPurify(root);\n    };\n\n    /**\n     * Version label, exposed for easier checks\n     * if DOMPurify is up to date or not\n     */\n    DOMPurify.version = '2.2.9';\n\n    /**\n     * Array of elements that DOMPurify removed during sanitation.\n     * Empty if nothing was removed.\n     */\n    DOMPurify.removed = [];\n\n    if (!window || !window.document || window.document.nodeType !== 9) {\n      // Not running in a browser, provide a factory function\n      // so that you can pass your own Window\n      DOMPurify.isSupported = false;\n\n      return DOMPurify;\n    }\n\n    var originalDocument = window.document;\n\n    var document = window.document;\n    var DocumentFragment = window.DocumentFragment,\n        HTMLTemplateElement = window.HTMLTemplateElement,\n        Node = window.Node,\n        Element = window.Element,\n        NodeFilter = window.NodeFilter,\n        _window$NamedNodeMap = window.NamedNodeMap,\n        NamedNodeMap = _window$NamedNodeMap === undefined ? window.NamedNodeMap || window.MozNamedAttrMap : _window$NamedNodeMap,\n        Text = window.Text,\n        Comment = window.Comment,\n        DOMParser = window.DOMParser,\n        trustedTypes = window.trustedTypes;\n\n\n    var ElementPrototype = Element.prototype;\n\n    var cloneNode = lookupGetter(ElementPrototype, 'cloneNode');\n    var getNextSibling = lookupGetter(ElementPrototype, 'nextSibling');\n    var getChildNodes = lookupGetter(ElementPrototype, 'childNodes');\n    var getParentNode = lookupGetter(ElementPrototype, 'parentNode');\n\n    // As per issue #47, the web-components registry is inherited by a\n    // new document created via createHTMLDocument. As per the spec\n    // (http://w3c.github.io/webcomponents/spec/custom/#creating-and-passing-registries)\n    // a new empty registry is used when creating a template contents owner\n    // document, so we use that as our parent document to ensure nothing\n    // is inherited.\n    if (typeof HTMLTemplateElement === 'function') {\n      var template = document.createElement('template');\n      if (template.content && template.content.ownerDocument) {\n        document = template.content.ownerDocument;\n      }\n    }\n\n    var trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, originalDocument);\n    var emptyHTML = trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML('') : '';\n\n    var _document = document,\n        implementation = _document.implementation,\n        createNodeIterator = _document.createNodeIterator,\n        createDocumentFragment = _document.createDocumentFragment;\n    var importNode = originalDocument.importNode;\n\n\n    var documentMode = {};\n    try {\n      documentMode = clone(document).documentMode ? document.documentMode : {};\n    } catch (_) {}\n\n    var hooks = {};\n\n    /**\n     * Expose whether this browser supports running the full DOMPurify.\n     */\n    DOMPurify.isSupported = typeof getParentNode === 'function' && implementation && typeof implementation.createHTMLDocument !== 'undefined' && documentMode !== 9;\n\n    var MUSTACHE_EXPR$$1 = MUSTACHE_EXPR,\n        ERB_EXPR$$1 = ERB_EXPR,\n        DATA_ATTR$$1 = DATA_ATTR,\n        ARIA_ATTR$$1 = ARIA_ATTR,\n        IS_SCRIPT_OR_DATA$$1 = IS_SCRIPT_OR_DATA,\n        ATTR_WHITESPACE$$1 = ATTR_WHITESPACE;\n    var IS_ALLOWED_URI$$1 = IS_ALLOWED_URI;\n\n    /**\n     * We consider the elements and attributes below to be safe. Ideally\n     * don't add any new ones but feel free to remove unwanted ones.\n     */\n\n    /* allowed element names */\n\n    var ALLOWED_TAGS = null;\n    var DEFAULT_ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray$1(html), _toConsumableArray$1(svg), _toConsumableArray$1(svgFilters), _toConsumableArray$1(mathMl), _toConsumableArray$1(text)));\n\n    /* Allowed attribute names */\n    var ALLOWED_ATTR = null;\n    var DEFAULT_ALLOWED_ATTR = addToSet({}, [].concat(_toConsumableArray$1(html$1), _toConsumableArray$1(svg$1), _toConsumableArray$1(mathMl$1), _toConsumableArray$1(xml)));\n\n    /* Explicitly forbidden tags (overrides ALLOWED_TAGS/ADD_TAGS) */\n    var FORBID_TAGS = null;\n\n    /* Explicitly forbidden attributes (overrides ALLOWED_ATTR/ADD_ATTR) */\n    var FORBID_ATTR = null;\n\n    /* Decide if ARIA attributes are okay */\n    var ALLOW_ARIA_ATTR = true;\n\n    /* Decide if custom data attributes are okay */\n    var ALLOW_DATA_ATTR = true;\n\n    /* Decide if unknown protocols are okay */\n    var ALLOW_UNKNOWN_PROTOCOLS = false;\n\n    /* Output should be safe for common template engines.\n     * This means, DOMPurify removes data attributes, mustaches and ERB\n     */\n    var SAFE_FOR_TEMPLATES = false;\n\n    /* Decide if document with <html>... should be returned */\n    var WHOLE_DOCUMENT = false;\n\n    /* Track whether config is already set on this instance of DOMPurify. */\n    var SET_CONFIG = false;\n\n    /* Decide if all elements (e.g. style, script) must be children of\n     * document.body. By default, browsers might move them to document.head */\n    var FORCE_BODY = false;\n\n    /* Decide if a DOM `HTMLBodyElement` should be returned, instead of a html\n     * string (or a TrustedHTML object if Trusted Types are supported).\n     * If `WHOLE_DOCUMENT` is enabled a `HTMLHtmlElement` will be returned instead\n     */\n    var RETURN_DOM = false;\n\n    /* Decide if a DOM `DocumentFragment` should be returned, instead of a html\n     * string  (or a TrustedHTML object if Trusted Types are supported) */\n    var RETURN_DOM_FRAGMENT = false;\n\n    /* If `RETURN_DOM` or `RETURN_DOM_FRAGMENT` is enabled, decide if the returned DOM\n     * `Node` is imported into the current `Document`. If this flag is not enabled the\n     * `Node` will belong (its ownerDocument) to a fresh `HTMLDocument`, created by\n     * DOMPurify.\n     *\n     * This defaults to `true` starting DOMPurify 2.2.0. Note that setting it to `false`\n     * might cause XSS from attacks hidden in closed shadowroots in case the browser\n     * supports Declarative Shadow: DOM https://web.dev/declarative-shadow-dom/\n     */\n    var RETURN_DOM_IMPORT = true;\n\n    /* Try to return a Trusted Type object instead of a string, return a string in\n     * case Trusted Types are not supported  */\n    var RETURN_TRUSTED_TYPE = false;\n\n    /* Output should be free from DOM clobbering attacks? */\n    var SANITIZE_DOM = true;\n\n    /* Keep element content when removing element? */\n    var KEEP_CONTENT = true;\n\n    /* If a `Node` is passed to sanitize(), then performs sanitization in-place instead\n     * of importing it into a new Document and returning a sanitized copy */\n    var IN_PLACE = false;\n\n    /* Allow usage of profiles like html, svg and mathMl */\n    var USE_PROFILES = {};\n\n    /* Tags to ignore content of when KEEP_CONTENT is true */\n    var FORBID_CONTENTS = addToSet({}, ['annotation-xml', 'audio', 'colgroup', 'desc', 'foreignobject', 'head', 'iframe', 'math', 'mi', 'mn', 'mo', 'ms', 'mtext', 'noembed', 'noframes', 'noscript', 'plaintext', 'script', 'style', 'svg', 'template', 'thead', 'title', 'video', 'xmp']);\n\n    /* Tags that are safe for data: URIs */\n    var DATA_URI_TAGS = null;\n    var DEFAULT_DATA_URI_TAGS = addToSet({}, ['audio', 'video', 'img', 'source', 'image', 'track']);\n\n    /* Attributes safe for values like \"javascript:\" */\n    var URI_SAFE_ATTRIBUTES = null;\n    var DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, ['alt', 'class', 'for', 'id', 'label', 'name', 'pattern', 'placeholder', 'summary', 'title', 'value', 'style', 'xmlns']);\n\n    var MATHML_NAMESPACE = 'http://www.w3.org/1998/Math/MathML';\n    var SVG_NAMESPACE = 'http://www.w3.org/2000/svg';\n    var HTML_NAMESPACE = 'http://www.w3.org/1999/xhtml';\n    /* Document namespace */\n    var NAMESPACE = HTML_NAMESPACE;\n    var IS_EMPTY_INPUT = false;\n\n    /* Keep a reference to config to pass to hooks */\n    var CONFIG = null;\n\n    /* Ideally, do not touch anything below this line */\n    /* ______________________________________________ */\n\n    var formElement = document.createElement('form');\n\n    /**\n     * _parseConfig\n     *\n     * @param  {Object} cfg optional config literal\n     */\n    // eslint-disable-next-line complexity\n    var _parseConfig = function _parseConfig(cfg) {\n      if (CONFIG && CONFIG === cfg) {\n        return;\n      }\n\n      /* Shield configuration object from tampering */\n      if (!cfg || (typeof cfg === 'undefined' ? 'undefined' : _typeof(cfg)) !== 'object') {\n        cfg = {};\n      }\n\n      /* Shield configuration object from prototype pollution */\n      cfg = clone(cfg);\n\n      /* Set configuration parameters */\n      ALLOWED_TAGS = 'ALLOWED_TAGS' in cfg ? addToSet({}, cfg.ALLOWED_TAGS) : DEFAULT_ALLOWED_TAGS;\n      ALLOWED_ATTR = 'ALLOWED_ATTR' in cfg ? addToSet({}, cfg.ALLOWED_ATTR) : DEFAULT_ALLOWED_ATTR;\n      URI_SAFE_ATTRIBUTES = 'ADD_URI_SAFE_ATTR' in cfg ? addToSet(clone(DEFAULT_URI_SAFE_ATTRIBUTES), cfg.ADD_URI_SAFE_ATTR) : DEFAULT_URI_SAFE_ATTRIBUTES;\n      DATA_URI_TAGS = 'ADD_DATA_URI_TAGS' in cfg ? addToSet(clone(DEFAULT_DATA_URI_TAGS), cfg.ADD_DATA_URI_TAGS) : DEFAULT_DATA_URI_TAGS;\n      FORBID_TAGS = 'FORBID_TAGS' in cfg ? addToSet({}, cfg.FORBID_TAGS) : {};\n      FORBID_ATTR = 'FORBID_ATTR' in cfg ? addToSet({}, cfg.FORBID_ATTR) : {};\n      USE_PROFILES = 'USE_PROFILES' in cfg ? cfg.USE_PROFILES : false;\n      ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false; // Default true\n      ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false; // Default true\n      ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false; // Default false\n      SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false; // Default false\n      WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false; // Default false\n      RETURN_DOM = cfg.RETURN_DOM || false; // Default false\n      RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false; // Default false\n      RETURN_DOM_IMPORT = cfg.RETURN_DOM_IMPORT !== false; // Default true\n      RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false; // Default false\n      FORCE_BODY = cfg.FORCE_BODY || false; // Default false\n      SANITIZE_DOM = cfg.SANITIZE_DOM !== false; // Default true\n      KEEP_CONTENT = cfg.KEEP_CONTENT !== false; // Default true\n      IN_PLACE = cfg.IN_PLACE || false; // Default false\n      IS_ALLOWED_URI$$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI$$1;\n      NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;\n      if (SAFE_FOR_TEMPLATES) {\n        ALLOW_DATA_ATTR = false;\n      }\n\n      if (RETURN_DOM_FRAGMENT) {\n        RETURN_DOM = true;\n      }\n\n      /* Parse profile info */\n      if (USE_PROFILES) {\n        ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray$1(text)));\n        ALLOWED_ATTR = [];\n        if (USE_PROFILES.html === true) {\n          addToSet(ALLOWED_TAGS, html);\n          addToSet(ALLOWED_ATTR, html$1);\n        }\n\n        if (USE_PROFILES.svg === true) {\n          addToSet(ALLOWED_TAGS, svg);\n          addToSet(ALLOWED_ATTR, svg$1);\n          addToSet(ALLOWED_ATTR, xml);\n        }\n\n        if (USE_PROFILES.svgFilters === true) {\n          addToSet(ALLOWED_TAGS, svgFilters);\n          addToSet(ALLOWED_ATTR, svg$1);\n          addToSet(ALLOWED_ATTR, xml);\n        }\n\n        if (USE_PROFILES.mathMl === true) {\n          addToSet(ALLOWED_TAGS, mathMl);\n          addToSet(ALLOWED_ATTR, mathMl$1);\n          addToSet(ALLOWED_ATTR, xml);\n        }\n      }\n\n      /* Merge configuration parameters */\n      if (cfg.ADD_TAGS) {\n        if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {\n          ALLOWED_TAGS = clone(ALLOWED_TAGS);\n        }\n\n        addToSet(ALLOWED_TAGS, cfg.ADD_TAGS);\n      }\n\n      if (cfg.ADD_ATTR) {\n        if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {\n          ALLOWED_ATTR = clone(ALLOWED_ATTR);\n        }\n\n        addToSet(ALLOWED_ATTR, cfg.ADD_ATTR);\n      }\n\n      if (cfg.ADD_URI_SAFE_ATTR) {\n        addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR);\n      }\n\n      /* Add #text in case KEEP_CONTENT is set to true */\n      if (KEEP_CONTENT) {\n        ALLOWED_TAGS['#text'] = true;\n      }\n\n      /* Add html, head and body to ALLOWED_TAGS in case WHOLE_DOCUMENT is true */\n      if (WHOLE_DOCUMENT) {\n        addToSet(ALLOWED_TAGS, ['html', 'head', 'body']);\n      }\n\n      /* Add tbody to ALLOWED_TAGS in case tables are permitted, see #286, #365 */\n      if (ALLOWED_TAGS.table) {\n        addToSet(ALLOWED_TAGS, ['tbody']);\n        delete FORBID_TAGS.tbody;\n      }\n\n      // Prevent further manipulation of configuration.\n      // Not available in IE8, Safari 5, etc.\n      if (freeze) {\n        freeze(cfg);\n      }\n\n      CONFIG = cfg;\n    };\n\n    var MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, ['mi', 'mo', 'mn', 'ms', 'mtext']);\n\n    var HTML_INTEGRATION_POINTS = addToSet({}, ['foreignobject', 'desc', 'title', 'annotation-xml']);\n\n    /* Keep track of all possible SVG and MathML tags\n     * so that we can perform the namespace checks\n     * correctly. */\n    var ALL_SVG_TAGS = addToSet({}, svg);\n    addToSet(ALL_SVG_TAGS, svgFilters);\n    addToSet(ALL_SVG_TAGS, svgDisallowed);\n\n    var ALL_MATHML_TAGS = addToSet({}, mathMl);\n    addToSet(ALL_MATHML_TAGS, mathMlDisallowed);\n\n    /**\n     *\n     *\n     * @param  {Element} element a DOM element whose namespace is being checked\n     * @returns {boolean} Return false if the element has a\n     *  namespace that a spec-compliant parser would never\n     *  return. Return true otherwise.\n     */\n    var _checkValidNamespace = function _checkValidNamespace(element) {\n      var parent = getParentNode(element);\n\n      // In JSDOM, if we're inside shadow DOM, then parentNode\n      // can be null. We just simulate parent in this case.\n      if (!parent || !parent.tagName) {\n        parent = {\n          namespaceURI: HTML_NAMESPACE,\n          tagName: 'template'\n        };\n      }\n\n      var tagName = stringToLowerCase(element.tagName);\n      var parentTagName = stringToLowerCase(parent.tagName);\n\n      if (element.namespaceURI === SVG_NAMESPACE) {\n        // The only way to switch from HTML namespace to SVG\n        // is via <svg>. If it happens via any other tag, then\n        // it should be killed.\n        if (parent.namespaceURI === HTML_NAMESPACE) {\n          return tagName === 'svg';\n        }\n\n        // The only way to switch from MathML to SVG is via\n        // svg if parent is either <annotation-xml> or MathML\n        // text integration points.\n        if (parent.namespaceURI === MATHML_NAMESPACE) {\n          return tagName === 'svg' && (parentTagName === 'annotation-xml' || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);\n        }\n\n        // We only allow elements that are defined in SVG\n        // spec. All others are disallowed in SVG namespace.\n        return Boolean(ALL_SVG_TAGS[tagName]);\n      }\n\n      if (element.namespaceURI === MATHML_NAMESPACE) {\n        // The only way to switch from HTML namespace to MathML\n        // is via <math>. If it happens via any other tag, then\n        // it should be killed.\n        if (parent.namespaceURI === HTML_NAMESPACE) {\n          return tagName === 'math';\n        }\n\n        // The only way to switch from SVG to MathML is via\n        // <math> and HTML integration points\n        if (parent.namespaceURI === SVG_NAMESPACE) {\n          return tagName === 'math' && HTML_INTEGRATION_POINTS[parentTagName];\n        }\n\n        // We only allow elements that are defined in MathML\n        // spec. All others are disallowed in MathML namespace.\n        return Boolean(ALL_MATHML_TAGS[tagName]);\n      }\n\n      if (element.namespaceURI === HTML_NAMESPACE) {\n        // The only way to switch from SVG to HTML is via\n        // HTML integration points, and from MathML to HTML\n        // is via MathML text integration points\n        if (parent.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {\n          return false;\n        }\n\n        if (parent.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {\n          return false;\n        }\n\n        // Certain elements are allowed in both SVG and HTML\n        // namespace. We need to specify them explicitly\n        // so that they don't get erronously deleted from\n        // HTML namespace.\n        var commonSvgAndHTMLElements = addToSet({}, ['title', 'style', 'font', 'a', 'script']);\n\n        // We disallow tags that are specific for MathML\n        // or SVG and should never appear in HTML namespace\n        return !ALL_MATHML_TAGS[tagName] && (commonSvgAndHTMLElements[tagName] || !ALL_SVG_TAGS[tagName]);\n      }\n\n      // The code should never reach this place (this means\n      // that the element somehow got namespace that is not\n      // HTML, SVG or MathML). Return false just in case.\n      return false;\n    };\n\n    /**\n     * _forceRemove\n     *\n     * @param  {Node} node a DOM node\n     */\n    var _forceRemove = function _forceRemove(node) {\n      arrayPush(DOMPurify.removed, { element: node });\n      try {\n        // eslint-disable-next-line unicorn/prefer-dom-node-remove\n        node.parentNode.removeChild(node);\n      } catch (_) {\n        try {\n          node.outerHTML = emptyHTML;\n        } catch (_) {\n          node.remove();\n        }\n      }\n    };\n\n    /**\n     * _removeAttribute\n     *\n     * @param  {String} name an Attribute name\n     * @param  {Node} node a DOM node\n     */\n    var _removeAttribute = function _removeAttribute(name, node) {\n      try {\n        arrayPush(DOMPurify.removed, {\n          attribute: node.getAttributeNode(name),\n          from: node\n        });\n      } catch (_) {\n        arrayPush(DOMPurify.removed, {\n          attribute: null,\n          from: node\n        });\n      }\n\n      node.removeAttribute(name);\n\n      // We void attribute values for unremovable \"is\"\" attributes\n      if (name === 'is' && !ALLOWED_ATTR[name]) {\n        if (RETURN_DOM || RETURN_DOM_FRAGMENT) {\n          try {\n            _forceRemove(node);\n          } catch (_) {}\n        } else {\n          try {\n            node.setAttribute(name, '');\n          } catch (_) {}\n        }\n      }\n    };\n\n    /**\n     * _initDocument\n     *\n     * @param  {String} dirty a string of dirty markup\n     * @return {Document} a DOM, filled with the dirty markup\n     */\n    var _initDocument = function _initDocument(dirty) {\n      /* Create a HTML document */\n      var doc = void 0;\n      var leadingWhitespace = void 0;\n\n      if (FORCE_BODY) {\n        dirty = '<remove></remove>' + dirty;\n      } else {\n        /* If FORCE_BODY isn't used, leading whitespace needs to be preserved manually */\n        var matches = stringMatch(dirty, /^[\\r\\n\\t ]+/);\n        leadingWhitespace = matches && matches[0];\n      }\n\n      var dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;\n      /*\n       * Use the DOMParser API by default, fallback later if needs be\n       * DOMParser not work for svg when has multiple root element.\n       */\n      if (NAMESPACE === HTML_NAMESPACE) {\n        try {\n          doc = new DOMParser().parseFromString(dirtyPayload, 'text/html');\n        } catch (_) {}\n      }\n\n      /* Use createHTMLDocument in case DOMParser is not available */\n      if (!doc || !doc.documentElement) {\n        doc = implementation.createDocument(NAMESPACE, 'template', null);\n        try {\n          doc.documentElement.innerHTML = IS_EMPTY_INPUT ? '' : dirtyPayload;\n        } catch (_) {\n          // Syntax error if dirtyPayload is invalid xml\n        }\n      }\n\n      var body = doc.body || doc.documentElement;\n\n      if (dirty && leadingWhitespace) {\n        body.insertBefore(document.createTextNode(leadingWhitespace), body.childNodes[0] || null);\n      }\n\n      /* Work on whole document or just its body */\n      return WHOLE_DOCUMENT ? doc.documentElement : body;\n    };\n\n    /**\n     * _createIterator\n     *\n     * @param  {Document} root document/fragment to create iterator for\n     * @return {Iterator} iterator instance\n     */\n    var _createIterator = function _createIterator(root) {\n      return createNodeIterator.call(root.ownerDocument || root, root, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT, null, false);\n    };\n\n    /**\n     * _isClobbered\n     *\n     * @param  {Node} elm element to check for clobbering attacks\n     * @return {Boolean} true if clobbered, false if safe\n     */\n    var _isClobbered = function _isClobbered(elm) {\n      if (elm instanceof Text || elm instanceof Comment) {\n        return false;\n      }\n\n      if (typeof elm.nodeName !== 'string' || typeof elm.textContent !== 'string' || typeof elm.removeChild !== 'function' || !(elm.attributes instanceof NamedNodeMap) || typeof elm.removeAttribute !== 'function' || typeof elm.setAttribute !== 'function' || typeof elm.namespaceURI !== 'string' || typeof elm.insertBefore !== 'function') {\n        return true;\n      }\n\n      return false;\n    };\n\n    /**\n     * _isNode\n     *\n     * @param  {Node} obj object to check whether it's a DOM node\n     * @return {Boolean} true is object is a DOM node\n     */\n    var _isNode = function _isNode(object) {\n      return (typeof Node === 'undefined' ? 'undefined' : _typeof(Node)) === 'object' ? object instanceof Node : object && (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string';\n    };\n\n    /**\n     * _executeHook\n     * Execute user configurable hooks\n     *\n     * @param  {String} entryPoint  Name of the hook's entry point\n     * @param  {Node} currentNode node to work on with the hook\n     * @param  {Object} data additional hook parameters\n     */\n    var _executeHook = function _executeHook(entryPoint, currentNode, data) {\n      if (!hooks[entryPoint]) {\n        return;\n      }\n\n      arrayForEach(hooks[entryPoint], function (hook) {\n        hook.call(DOMPurify, currentNode, data, CONFIG);\n      });\n    };\n\n    /**\n     * _sanitizeElements\n     *\n     * @protect nodeName\n     * @protect textContent\n     * @protect removeChild\n     *\n     * @param   {Node} currentNode to check for permission to exist\n     * @return  {Boolean} true if node was killed, false if left alive\n     */\n    var _sanitizeElements = function _sanitizeElements(currentNode) {\n      var content = void 0;\n\n      /* Execute a hook if present */\n      _executeHook('beforeSanitizeElements', currentNode, null);\n\n      /* Check if element is clobbered or can clobber */\n      if (_isClobbered(currentNode)) {\n        _forceRemove(currentNode);\n        return true;\n      }\n\n      /* Check if tagname contains Unicode */\n      if (stringMatch(currentNode.nodeName, /[\\u0080-\\uFFFF]/)) {\n        _forceRemove(currentNode);\n        return true;\n      }\n\n      /* Now let's check the element's type and name */\n      var tagName = stringToLowerCase(currentNode.nodeName);\n\n      /* Execute a hook if present */\n      _executeHook('uponSanitizeElement', currentNode, {\n        tagName: tagName,\n        allowedTags: ALLOWED_TAGS\n      });\n\n      /* Detect mXSS attempts abusing namespace confusion */\n      if (!_isNode(currentNode.firstElementChild) && (!_isNode(currentNode.content) || !_isNode(currentNode.content.firstElementChild)) && regExpTest(/<[/\\w]/g, currentNode.innerHTML) && regExpTest(/<[/\\w]/g, currentNode.textContent)) {\n        _forceRemove(currentNode);\n        return true;\n      }\n\n      /* Remove element if anything forbids its presence */\n      if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {\n        /* Keep content except for bad-listed elements */\n        if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {\n          var parentNode = getParentNode(currentNode) || currentNode.parentNode;\n          var childNodes = getChildNodes(currentNode) || currentNode.childNodes;\n\n          if (childNodes && parentNode) {\n            var childCount = childNodes.length;\n\n            for (var i = childCount - 1; i >= 0; --i) {\n              parentNode.insertBefore(cloneNode(childNodes[i], true), getNextSibling(currentNode));\n            }\n          }\n        }\n\n        _forceRemove(currentNode);\n        return true;\n      }\n\n      /* Check whether element has a valid namespace */\n      if (currentNode instanceof Element && !_checkValidNamespace(currentNode)) {\n        _forceRemove(currentNode);\n        return true;\n      }\n\n      if ((tagName === 'noscript' || tagName === 'noembed') && regExpTest(/<\\/no(script|embed)/i, currentNode.innerHTML)) {\n        _forceRemove(currentNode);\n        return true;\n      }\n\n      /* Sanitize element content to be template-safe */\n      if (SAFE_FOR_TEMPLATES && currentNode.nodeType === 3) {\n        /* Get the element's text content */\n        content = currentNode.textContent;\n        content = stringReplace(content, MUSTACHE_EXPR$$1, ' ');\n        content = stringReplace(content, ERB_EXPR$$1, ' ');\n        if (currentNode.textContent !== content) {\n          arrayPush(DOMPurify.removed, { element: currentNode.cloneNode() });\n          currentNode.textContent = content;\n        }\n      }\n\n      /* Execute a hook if present */\n      _executeHook('afterSanitizeElements', currentNode, null);\n\n      return false;\n    };\n\n    /**\n     * _isValidAttribute\n     *\n     * @param  {string} lcTag Lowercase tag name of containing element.\n     * @param  {string} lcName Lowercase attribute name.\n     * @param  {string} value Attribute value.\n     * @return {Boolean} Returns true if `value` is valid, otherwise false.\n     */\n    // eslint-disable-next-line complexity\n    var _isValidAttribute = function _isValidAttribute(lcTag, lcName, value) {\n      /* Make sure attribute cannot clobber */\n      if (SANITIZE_DOM && (lcName === 'id' || lcName === 'name') && (value in document || value in formElement)) {\n        return false;\n      }\n\n      /* Allow valid data-* attributes: At least one character after \"-\"\n          (https://html.spec.whatwg.org/multipage/dom.html#embedding-custom-non-visible-data-with-the-data-*-attributes)\n          XML-compatible (https://html.spec.whatwg.org/multipage/infrastructure.html#xml-compatible and http://www.w3.org/TR/xml/#d0e804)\n          We don't need to check the value; it's always URI safe. */\n      if (ALLOW_DATA_ATTR && regExpTest(DATA_ATTR$$1, lcName)) ; else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR$$1, lcName)) ; else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {\n        return false;\n\n        /* Check value is safe. First, is attr inert? If so, is safe */\n      } else if (URI_SAFE_ATTRIBUTES[lcName]) ; else if (regExpTest(IS_ALLOWED_URI$$1, stringReplace(value, ATTR_WHITESPACE$$1, ''))) ; else if ((lcName === 'src' || lcName === 'xlink:href' || lcName === 'href') && lcTag !== 'script' && stringIndexOf(value, 'data:') === 0 && DATA_URI_TAGS[lcTag]) ; else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA$$1, stringReplace(value, ATTR_WHITESPACE$$1, ''))) ; else if (!value) ; else {\n        return false;\n      }\n\n      return true;\n    };\n\n    /**\n     * _sanitizeAttributes\n     *\n     * @protect attributes\n     * @protect nodeName\n     * @protect removeAttribute\n     * @protect setAttribute\n     *\n     * @param  {Node} currentNode to sanitize\n     */\n    var _sanitizeAttributes = function _sanitizeAttributes(currentNode) {\n      var attr = void 0;\n      var value = void 0;\n      var lcName = void 0;\n      var l = void 0;\n      /* Execute a hook if present */\n      _executeHook('beforeSanitizeAttributes', currentNode, null);\n\n      var attributes = currentNode.attributes;\n\n      /* Check if we have attributes; if not we might have a text node */\n\n      if (!attributes) {\n        return;\n      }\n\n      var hookEvent = {\n        attrName: '',\n        attrValue: '',\n        keepAttr: true,\n        allowedAttributes: ALLOWED_ATTR\n      };\n      l = attributes.length;\n\n      /* Go backwards over all attributes; safely remove bad ones */\n      while (l--) {\n        attr = attributes[l];\n        var _attr = attr,\n            name = _attr.name,\n            namespaceURI = _attr.namespaceURI;\n\n        value = stringTrim(attr.value);\n        lcName = stringToLowerCase(name);\n\n        /* Execute a hook if present */\n        hookEvent.attrName = lcName;\n        hookEvent.attrValue = value;\n        hookEvent.keepAttr = true;\n        hookEvent.forceKeepAttr = undefined; // Allows developers to see this is a property they can set\n        _executeHook('uponSanitizeAttribute', currentNode, hookEvent);\n        value = hookEvent.attrValue;\n        /* Did the hooks approve of the attribute? */\n        if (hookEvent.forceKeepAttr) {\n          continue;\n        }\n\n        /* Remove attribute */\n        _removeAttribute(name, currentNode);\n\n        /* Did the hooks approve of the attribute? */\n        if (!hookEvent.keepAttr) {\n          continue;\n        }\n\n        /* Work around a security issue in jQuery 3.0 */\n        if (regExpTest(/\\/>/i, value)) {\n          _removeAttribute(name, currentNode);\n          continue;\n        }\n\n        /* Sanitize attribute content to be template-safe */\n        if (SAFE_FOR_TEMPLATES) {\n          value = stringReplace(value, MUSTACHE_EXPR$$1, ' ');\n          value = stringReplace(value, ERB_EXPR$$1, ' ');\n        }\n\n        /* Is `value` valid for this attribute? */\n        var lcTag = currentNode.nodeName.toLowerCase();\n        if (!_isValidAttribute(lcTag, lcName, value)) {\n          continue;\n        }\n\n        /* Handle invalid data-* attribute set by try-catching it */\n        try {\n          if (namespaceURI) {\n            currentNode.setAttributeNS(namespaceURI, name, value);\n          } else {\n            /* Fallback to setAttribute() for browser-unrecognized namespaces e.g. \"x-schema\". */\n            currentNode.setAttribute(name, value);\n          }\n\n          arrayPop(DOMPurify.removed);\n        } catch (_) {}\n      }\n\n      /* Execute a hook if present */\n      _executeHook('afterSanitizeAttributes', currentNode, null);\n    };\n\n    /**\n     * _sanitizeShadowDOM\n     *\n     * @param  {DocumentFragment} fragment to iterate over recursively\n     */\n    var _sanitizeShadowDOM = function _sanitizeShadowDOM(fragment) {\n      var shadowNode = void 0;\n      var shadowIterator = _createIterator(fragment);\n\n      /* Execute a hook if present */\n      _executeHook('beforeSanitizeShadowDOM', fragment, null);\n\n      while (shadowNode = shadowIterator.nextNode()) {\n        /* Execute a hook if present */\n        _executeHook('uponSanitizeShadowNode', shadowNode, null);\n\n        /* Sanitize tags and elements */\n        if (_sanitizeElements(shadowNode)) {\n          continue;\n        }\n\n        /* Deep shadow DOM detected */\n        if (shadowNode.content instanceof DocumentFragment) {\n          _sanitizeShadowDOM(shadowNode.content);\n        }\n\n        /* Check attributes, sanitize if necessary */\n        _sanitizeAttributes(shadowNode);\n      }\n\n      /* Execute a hook if present */\n      _executeHook('afterSanitizeShadowDOM', fragment, null);\n    };\n\n    /**\n     * Sanitize\n     * Public method providing core sanitation functionality\n     *\n     * @param {String|Node} dirty string or DOM node\n     * @param {Object} configuration object\n     */\n    // eslint-disable-next-line complexity\n    DOMPurify.sanitize = function (dirty, cfg) {\n      var body = void 0;\n      var importedNode = void 0;\n      var currentNode = void 0;\n      var oldNode = void 0;\n      var returnNode = void 0;\n      /* Make sure we have a string to sanitize.\n        DO NOT return early, as this will return the wrong type if\n        the user has requested a DOM object rather than a string */\n      IS_EMPTY_INPUT = !dirty;\n      if (IS_EMPTY_INPUT) {\n        dirty = '<!-->';\n      }\n\n      /* Stringify, in case dirty is an object */\n      if (typeof dirty !== 'string' && !_isNode(dirty)) {\n        // eslint-disable-next-line no-negated-condition\n        if (typeof dirty.toString !== 'function') {\n          throw typeErrorCreate('toString is not a function');\n        } else {\n          dirty = dirty.toString();\n          if (typeof dirty !== 'string') {\n            throw typeErrorCreate('dirty is not a string, aborting');\n          }\n        }\n      }\n\n      /* Check we can run. Otherwise fall back or ignore */\n      if (!DOMPurify.isSupported) {\n        if (_typeof(window.toStaticHTML) === 'object' || typeof window.toStaticHTML === 'function') {\n          if (typeof dirty === 'string') {\n            return window.toStaticHTML(dirty);\n          }\n\n          if (_isNode(dirty)) {\n            return window.toStaticHTML(dirty.outerHTML);\n          }\n        }\n\n        return dirty;\n      }\n\n      /* Assign config vars */\n      if (!SET_CONFIG) {\n        _parseConfig(cfg);\n      }\n\n      /* Clean up removed elements */\n      DOMPurify.removed = [];\n\n      /* Check if dirty is correctly typed for IN_PLACE */\n      if (typeof dirty === 'string') {\n        IN_PLACE = false;\n      }\n\n      if (IN_PLACE) ; else if (dirty instanceof Node) {\n        /* If dirty is a DOM element, append to an empty document to avoid\n           elements being stripped by the parser */\n        body = _initDocument('<!---->');\n        importedNode = body.ownerDocument.importNode(dirty, true);\n        if (importedNode.nodeType === 1 && importedNode.nodeName === 'BODY') {\n          /* Node is already a body, use as is */\n          body = importedNode;\n        } else if (importedNode.nodeName === 'HTML') {\n          body = importedNode;\n        } else {\n          // eslint-disable-next-line unicorn/prefer-dom-node-append\n          body.appendChild(importedNode);\n        }\n      } else {\n        /* Exit directly if we have nothing to do */\n        if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT &&\n        // eslint-disable-next-line unicorn/prefer-includes\n        dirty.indexOf('<') === -1) {\n          return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;\n        }\n\n        /* Initialize the document to work on */\n        body = _initDocument(dirty);\n\n        /* Check we have a DOM node from the data */\n        if (!body) {\n          return RETURN_DOM ? null : emptyHTML;\n        }\n      }\n\n      /* Remove first element node (ours) if FORCE_BODY is set */\n      if (body && FORCE_BODY) {\n        _forceRemove(body.firstChild);\n      }\n\n      /* Get node iterator */\n      var nodeIterator = _createIterator(IN_PLACE ? dirty : body);\n\n      /* Now start iterating over the created document */\n      while (currentNode = nodeIterator.nextNode()) {\n        /* Fix IE's strange behavior with manipulated textNodes #89 */\n        if (currentNode.nodeType === 3 && currentNode === oldNode) {\n          continue;\n        }\n\n        /* Sanitize tags and elements */\n        if (_sanitizeElements(currentNode)) {\n          continue;\n        }\n\n        /* Shadow DOM detected, sanitize it */\n        if (currentNode.content instanceof DocumentFragment) {\n          _sanitizeShadowDOM(currentNode.content);\n        }\n\n        /* Check attributes, sanitize if necessary */\n        _sanitizeAttributes(currentNode);\n\n        oldNode = currentNode;\n      }\n\n      oldNode = null;\n\n      /* If we sanitized `dirty` in-place, return it. */\n      if (IN_PLACE) {\n        return dirty;\n      }\n\n      /* Return sanitized string or DOM */\n      if (RETURN_DOM) {\n        if (RETURN_DOM_FRAGMENT) {\n          returnNode = createDocumentFragment.call(body.ownerDocument);\n\n          while (body.firstChild) {\n            // eslint-disable-next-line unicorn/prefer-dom-node-append\n            returnNode.appendChild(body.firstChild);\n          }\n        } else {\n          returnNode = body;\n        }\n\n        if (RETURN_DOM_IMPORT) {\n          /*\n            AdoptNode() is not used because internal state is not reset\n            (e.g. the past names map of a HTMLFormElement), this is safe\n            in theory but we would rather not risk another attack vector.\n            The state that is cloned by importNode() is explicitly defined\n            by the specs.\n          */\n          returnNode = importNode.call(originalDocument, returnNode, true);\n        }\n\n        return returnNode;\n      }\n\n      var serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;\n\n      /* Sanitize final string template-safe */\n      if (SAFE_FOR_TEMPLATES) {\n        serializedHTML = stringReplace(serializedHTML, MUSTACHE_EXPR$$1, ' ');\n        serializedHTML = stringReplace(serializedHTML, ERB_EXPR$$1, ' ');\n      }\n\n      return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;\n    };\n\n    /**\n     * Public method to set the configuration once\n     * setConfig\n     *\n     * @param {Object} cfg configuration object\n     */\n    DOMPurify.setConfig = function (cfg) {\n      _parseConfig(cfg);\n      SET_CONFIG = true;\n    };\n\n    /**\n     * Public method to remove the configuration\n     * clearConfig\n     *\n     */\n    DOMPurify.clearConfig = function () {\n      CONFIG = null;\n      SET_CONFIG = false;\n    };\n\n    /**\n     * Public method to check if an attribute value is valid.\n     * Uses last set config, if any. Otherwise, uses config defaults.\n     * isValidAttribute\n     *\n     * @param  {string} tag Tag name of containing element.\n     * @param  {string} attr Attribute name.\n     * @param  {string} value Attribute value.\n     * @return {Boolean} Returns true if `value` is valid. Otherwise, returns false.\n     */\n    DOMPurify.isValidAttribute = function (tag, attr, value) {\n      /* Initialize shared config vars if necessary. */\n      if (!CONFIG) {\n        _parseConfig({});\n      }\n\n      var lcTag = stringToLowerCase(tag);\n      var lcName = stringToLowerCase(attr);\n      return _isValidAttribute(lcTag, lcName, value);\n    };\n\n    /**\n     * AddHook\n     * Public method to add DOMPurify hooks\n     *\n     * @param {String} entryPoint entry point for the hook to add\n     * @param {Function} hookFunction function to execute\n     */\n    DOMPurify.addHook = function (entryPoint, hookFunction) {\n      if (typeof hookFunction !== 'function') {\n        return;\n      }\n\n      hooks[entryPoint] = hooks[entryPoint] || [];\n      arrayPush(hooks[entryPoint], hookFunction);\n    };\n\n    /**\n     * RemoveHook\n     * Public method to remove a DOMPurify hook at a given entryPoint\n     * (pops it from the stack of hooks if more are present)\n     *\n     * @param {String} entryPoint entry point for the hook to remove\n     */\n    DOMPurify.removeHook = function (entryPoint) {\n      if (hooks[entryPoint]) {\n        arrayPop(hooks[entryPoint]);\n      }\n    };\n\n    /**\n     * RemoveHooks\n     * Public method to remove all DOMPurify hooks at a given entryPoint\n     *\n     * @param  {String} entryPoint entry point for the hooks to remove\n     */\n    DOMPurify.removeHooks = function (entryPoint) {\n      if (hooks[entryPoint]) {\n        hooks[entryPoint] = [];\n      }\n    };\n\n    /**\n     * RemoveAllHooks\n     * Public method to remove all DOMPurify hooks\n     *\n     */\n    DOMPurify.removeAllHooks = function () {\n      hooks = {};\n    };\n\n    return DOMPurify;\n  }\n\n  var purify = createDOMPurify();\n\n  return purify;\n\n}));\n//# sourceMappingURL=purify.js.map\n\n\n//# sourceURL=webpack:///./node_modules/dompurify/dist/purify.js?");

/***/ }),

/***/ "./node_modules/isomorphic-fetch/fetch-npm-browserify.js":
/*!***************************************************************!*\
  !*** ./node_modules/isomorphic-fetch/fetch-npm-browserify.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// the whatwg-fetch polyfill installs the fetch() function\n// on the global object (window or self)\n//\n// Return that as the export for use in Webpack, Browserify etc.\n__webpack_require__(/*! whatwg-fetch */ \"./node_modules/whatwg-fetch/fetch.js\");\nmodule.exports = self.fetch.bind(self);\n\n\n//# sourceURL=webpack:///./node_modules/isomorphic-fetch/fetch-npm-browserify.js?");

/***/ }),

/***/ "./node_modules/localforage/dist/localforage.js":
/*!******************************************************!*\
  !*** ./node_modules/localforage/dist/localforage.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {var require;var require;/*!\n    localForage -- Offline Storage, Improved\n    Version 1.9.0\n    https://localforage.github.io/localForage\n    (c) 2013-2017 Mozilla, Apache License 2.0\n*/\n(function(f){if(true){module.exports=f()}else { var g; }})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return require(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw (f.code=\"MODULE_NOT_FOUND\", f)}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){\n(function (global){\n'use strict';\nvar Mutation = global.MutationObserver || global.WebKitMutationObserver;\n\nvar scheduleDrain;\n\n{\n  if (Mutation) {\n    var called = 0;\n    var observer = new Mutation(nextTick);\n    var element = global.document.createTextNode('');\n    observer.observe(element, {\n      characterData: true\n    });\n    scheduleDrain = function () {\n      element.data = (called = ++called % 2);\n    };\n  } else if (!global.setImmediate && typeof global.MessageChannel !== 'undefined') {\n    var channel = new global.MessageChannel();\n    channel.port1.onmessage = nextTick;\n    scheduleDrain = function () {\n      channel.port2.postMessage(0);\n    };\n  } else if ('document' in global && 'onreadystatechange' in global.document.createElement('script')) {\n    scheduleDrain = function () {\n\n      // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n      // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n      var scriptEl = global.document.createElement('script');\n      scriptEl.onreadystatechange = function () {\n        nextTick();\n\n        scriptEl.onreadystatechange = null;\n        scriptEl.parentNode.removeChild(scriptEl);\n        scriptEl = null;\n      };\n      global.document.documentElement.appendChild(scriptEl);\n    };\n  } else {\n    scheduleDrain = function () {\n      setTimeout(nextTick, 0);\n    };\n  }\n}\n\nvar draining;\nvar queue = [];\n//named nextTick for less confusing stack traces\nfunction nextTick() {\n  draining = true;\n  var i, oldQueue;\n  var len = queue.length;\n  while (len) {\n    oldQueue = queue;\n    queue = [];\n    i = -1;\n    while (++i < len) {\n      oldQueue[i]();\n    }\n    len = queue.length;\n  }\n  draining = false;\n}\n\nmodule.exports = immediate;\nfunction immediate(task) {\n  if (queue.push(task) === 1 && !draining) {\n    scheduleDrain();\n  }\n}\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{}],2:[function(_dereq_,module,exports){\n'use strict';\nvar immediate = _dereq_(1);\n\n/* istanbul ignore next */\nfunction INTERNAL() {}\n\nvar handlers = {};\n\nvar REJECTED = ['REJECTED'];\nvar FULFILLED = ['FULFILLED'];\nvar PENDING = ['PENDING'];\n\nmodule.exports = Promise;\n\nfunction Promise(resolver) {\n  if (typeof resolver !== 'function') {\n    throw new TypeError('resolver must be a function');\n  }\n  this.state = PENDING;\n  this.queue = [];\n  this.outcome = void 0;\n  if (resolver !== INTERNAL) {\n    safelyResolveThenable(this, resolver);\n  }\n}\n\nPromise.prototype[\"catch\"] = function (onRejected) {\n  return this.then(null, onRejected);\n};\nPromise.prototype.then = function (onFulfilled, onRejected) {\n  if (typeof onFulfilled !== 'function' && this.state === FULFILLED ||\n    typeof onRejected !== 'function' && this.state === REJECTED) {\n    return this;\n  }\n  var promise = new this.constructor(INTERNAL);\n  if (this.state !== PENDING) {\n    var resolver = this.state === FULFILLED ? onFulfilled : onRejected;\n    unwrap(promise, resolver, this.outcome);\n  } else {\n    this.queue.push(new QueueItem(promise, onFulfilled, onRejected));\n  }\n\n  return promise;\n};\nfunction QueueItem(promise, onFulfilled, onRejected) {\n  this.promise = promise;\n  if (typeof onFulfilled === 'function') {\n    this.onFulfilled = onFulfilled;\n    this.callFulfilled = this.otherCallFulfilled;\n  }\n  if (typeof onRejected === 'function') {\n    this.onRejected = onRejected;\n    this.callRejected = this.otherCallRejected;\n  }\n}\nQueueItem.prototype.callFulfilled = function (value) {\n  handlers.resolve(this.promise, value);\n};\nQueueItem.prototype.otherCallFulfilled = function (value) {\n  unwrap(this.promise, this.onFulfilled, value);\n};\nQueueItem.prototype.callRejected = function (value) {\n  handlers.reject(this.promise, value);\n};\nQueueItem.prototype.otherCallRejected = function (value) {\n  unwrap(this.promise, this.onRejected, value);\n};\n\nfunction unwrap(promise, func, value) {\n  immediate(function () {\n    var returnValue;\n    try {\n      returnValue = func(value);\n    } catch (e) {\n      return handlers.reject(promise, e);\n    }\n    if (returnValue === promise) {\n      handlers.reject(promise, new TypeError('Cannot resolve promise with itself'));\n    } else {\n      handlers.resolve(promise, returnValue);\n    }\n  });\n}\n\nhandlers.resolve = function (self, value) {\n  var result = tryCatch(getThen, value);\n  if (result.status === 'error') {\n    return handlers.reject(self, result.value);\n  }\n  var thenable = result.value;\n\n  if (thenable) {\n    safelyResolveThenable(self, thenable);\n  } else {\n    self.state = FULFILLED;\n    self.outcome = value;\n    var i = -1;\n    var len = self.queue.length;\n    while (++i < len) {\n      self.queue[i].callFulfilled(value);\n    }\n  }\n  return self;\n};\nhandlers.reject = function (self, error) {\n  self.state = REJECTED;\n  self.outcome = error;\n  var i = -1;\n  var len = self.queue.length;\n  while (++i < len) {\n    self.queue[i].callRejected(error);\n  }\n  return self;\n};\n\nfunction getThen(obj) {\n  // Make sure we only access the accessor once as required by the spec\n  var then = obj && obj.then;\n  if (obj && (typeof obj === 'object' || typeof obj === 'function') && typeof then === 'function') {\n    return function appyThen() {\n      then.apply(obj, arguments);\n    };\n  }\n}\n\nfunction safelyResolveThenable(self, thenable) {\n  // Either fulfill, reject or reject with error\n  var called = false;\n  function onError(value) {\n    if (called) {\n      return;\n    }\n    called = true;\n    handlers.reject(self, value);\n  }\n\n  function onSuccess(value) {\n    if (called) {\n      return;\n    }\n    called = true;\n    handlers.resolve(self, value);\n  }\n\n  function tryToUnwrap() {\n    thenable(onSuccess, onError);\n  }\n\n  var result = tryCatch(tryToUnwrap);\n  if (result.status === 'error') {\n    onError(result.value);\n  }\n}\n\nfunction tryCatch(func, value) {\n  var out = {};\n  try {\n    out.value = func(value);\n    out.status = 'success';\n  } catch (e) {\n    out.status = 'error';\n    out.value = e;\n  }\n  return out;\n}\n\nPromise.resolve = resolve;\nfunction resolve(value) {\n  if (value instanceof this) {\n    return value;\n  }\n  return handlers.resolve(new this(INTERNAL), value);\n}\n\nPromise.reject = reject;\nfunction reject(reason) {\n  var promise = new this(INTERNAL);\n  return handlers.reject(promise, reason);\n}\n\nPromise.all = all;\nfunction all(iterable) {\n  var self = this;\n  if (Object.prototype.toString.call(iterable) !== '[object Array]') {\n    return this.reject(new TypeError('must be an array'));\n  }\n\n  var len = iterable.length;\n  var called = false;\n  if (!len) {\n    return this.resolve([]);\n  }\n\n  var values = new Array(len);\n  var resolved = 0;\n  var i = -1;\n  var promise = new this(INTERNAL);\n\n  while (++i < len) {\n    allResolver(iterable[i], i);\n  }\n  return promise;\n  function allResolver(value, i) {\n    self.resolve(value).then(resolveFromAll, function (error) {\n      if (!called) {\n        called = true;\n        handlers.reject(promise, error);\n      }\n    });\n    function resolveFromAll(outValue) {\n      values[i] = outValue;\n      if (++resolved === len && !called) {\n        called = true;\n        handlers.resolve(promise, values);\n      }\n    }\n  }\n}\n\nPromise.race = race;\nfunction race(iterable) {\n  var self = this;\n  if (Object.prototype.toString.call(iterable) !== '[object Array]') {\n    return this.reject(new TypeError('must be an array'));\n  }\n\n  var len = iterable.length;\n  var called = false;\n  if (!len) {\n    return this.resolve([]);\n  }\n\n  var i = -1;\n  var promise = new this(INTERNAL);\n\n  while (++i < len) {\n    resolver(iterable[i]);\n  }\n  return promise;\n  function resolver(value) {\n    self.resolve(value).then(function (response) {\n      if (!called) {\n        called = true;\n        handlers.resolve(promise, response);\n      }\n    }, function (error) {\n      if (!called) {\n        called = true;\n        handlers.reject(promise, error);\n      }\n    });\n  }\n}\n\n},{\"1\":1}],3:[function(_dereq_,module,exports){\n(function (global){\n'use strict';\nif (typeof global.Promise !== 'function') {\n  global.Promise = _dereq_(2);\n}\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"2\":2}],4:[function(_dereq_,module,exports){\n'use strict';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction getIDB() {\n    /* global indexedDB,webkitIndexedDB,mozIndexedDB,OIndexedDB,msIndexedDB */\n    try {\n        if (typeof indexedDB !== 'undefined') {\n            return indexedDB;\n        }\n        if (typeof webkitIndexedDB !== 'undefined') {\n            return webkitIndexedDB;\n        }\n        if (typeof mozIndexedDB !== 'undefined') {\n            return mozIndexedDB;\n        }\n        if (typeof OIndexedDB !== 'undefined') {\n            return OIndexedDB;\n        }\n        if (typeof msIndexedDB !== 'undefined') {\n            return msIndexedDB;\n        }\n    } catch (e) {\n        return;\n    }\n}\n\nvar idb = getIDB();\n\nfunction isIndexedDBValid() {\n    try {\n        // Initialize IndexedDB; fall back to vendor-prefixed versions\n        // if needed.\n        if (!idb || !idb.open) {\n            return false;\n        }\n        // We mimic PouchDB here;\n        //\n        // We test for openDatabase because IE Mobile identifies itself\n        // as Safari. Oh the lulz...\n        var isSafari = typeof openDatabase !== 'undefined' && /(Safari|iPhone|iPad|iPod)/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent) && !/BlackBerry/.test(navigator.platform);\n\n        var hasFetch = typeof fetch === 'function' && fetch.toString().indexOf('[native code') !== -1;\n\n        // Safari <10.1 does not meet our requirements for IDB support\n        // (see: https://github.com/pouchdb/pouchdb/issues/5572).\n        // Safari 10.1 shipped with fetch, we can use that to detect it.\n        // Note: this creates issues with `window.fetch` polyfills and\n        // overrides; see:\n        // https://github.com/localForage/localForage/issues/856\n        return (!isSafari || hasFetch) && typeof indexedDB !== 'undefined' &&\n        // some outdated implementations of IDB that appear on Samsung\n        // and HTC Android devices <4.4 are missing IDBKeyRange\n        // See: https://github.com/mozilla/localForage/issues/128\n        // See: https://github.com/mozilla/localForage/issues/272\n        typeof IDBKeyRange !== 'undefined';\n    } catch (e) {\n        return false;\n    }\n}\n\n// Abstracts constructing a Blob object, so it also works in older\n// browsers that don't support the native Blob constructor. (i.e.\n// old QtWebKit versions, at least).\n// Abstracts constructing a Blob object, so it also works in older\n// browsers that don't support the native Blob constructor. (i.e.\n// old QtWebKit versions, at least).\nfunction createBlob(parts, properties) {\n    /* global BlobBuilder,MSBlobBuilder,MozBlobBuilder,WebKitBlobBuilder */\n    parts = parts || [];\n    properties = properties || {};\n    try {\n        return new Blob(parts, properties);\n    } catch (e) {\n        if (e.name !== 'TypeError') {\n            throw e;\n        }\n        var Builder = typeof BlobBuilder !== 'undefined' ? BlobBuilder : typeof MSBlobBuilder !== 'undefined' ? MSBlobBuilder : typeof MozBlobBuilder !== 'undefined' ? MozBlobBuilder : WebKitBlobBuilder;\n        var builder = new Builder();\n        for (var i = 0; i < parts.length; i += 1) {\n            builder.append(parts[i]);\n        }\n        return builder.getBlob(properties.type);\n    }\n}\n\n// This is CommonJS because lie is an external dependency, so Rollup\n// can just ignore it.\nif (typeof Promise === 'undefined') {\n    // In the \"nopromises\" build this will just throw if you don't have\n    // a global promise object, but it would throw anyway later.\n    _dereq_(3);\n}\nvar Promise$1 = Promise;\n\nfunction executeCallback(promise, callback) {\n    if (callback) {\n        promise.then(function (result) {\n            callback(null, result);\n        }, function (error) {\n            callback(error);\n        });\n    }\n}\n\nfunction executeTwoCallbacks(promise, callback, errorCallback) {\n    if (typeof callback === 'function') {\n        promise.then(callback);\n    }\n\n    if (typeof errorCallback === 'function') {\n        promise[\"catch\"](errorCallback);\n    }\n}\n\nfunction normalizeKey(key) {\n    // Cast the key to a string, as that's all we can set as a key.\n    if (typeof key !== 'string') {\n        console.warn(key + ' used as a key, but it is not a string.');\n        key = String(key);\n    }\n\n    return key;\n}\n\nfunction getCallback() {\n    if (arguments.length && typeof arguments[arguments.length - 1] === 'function') {\n        return arguments[arguments.length - 1];\n    }\n}\n\n// Some code originally from async_storage.js in\n// [Gaia](https://github.com/mozilla-b2g/gaia).\n\nvar DETECT_BLOB_SUPPORT_STORE = 'local-forage-detect-blob-support';\nvar supportsBlobs = void 0;\nvar dbContexts = {};\nvar toString = Object.prototype.toString;\n\n// Transaction Modes\nvar READ_ONLY = 'readonly';\nvar READ_WRITE = 'readwrite';\n\n// Transform a binary string to an array buffer, because otherwise\n// weird stuff happens when you try to work with the binary string directly.\n// It is known.\n// From http://stackoverflow.com/questions/14967647/ (continues on next line)\n// encode-decode-image-with-base64-breaks-image (2013-04-21)\nfunction _binStringToArrayBuffer(bin) {\n    var length = bin.length;\n    var buf = new ArrayBuffer(length);\n    var arr = new Uint8Array(buf);\n    for (var i = 0; i < length; i++) {\n        arr[i] = bin.charCodeAt(i);\n    }\n    return buf;\n}\n\n//\n// Blobs are not supported in all versions of IndexedDB, notably\n// Chrome <37 and Android <5. In those versions, storing a blob will throw.\n//\n// Various other blob bugs exist in Chrome v37-42 (inclusive).\n// Detecting them is expensive and confusing to users, and Chrome 37-42\n// is at very low usage worldwide, so we do a hacky userAgent check instead.\n//\n// content-type bug: https://code.google.com/p/chromium/issues/detail?id=408120\n// 404 bug: https://code.google.com/p/chromium/issues/detail?id=447916\n// FileReader bug: https://code.google.com/p/chromium/issues/detail?id=447836\n//\n// Code borrowed from PouchDB. See:\n// https://github.com/pouchdb/pouchdb/blob/master/packages/node_modules/pouchdb-adapter-idb/src/blobSupport.js\n//\nfunction _checkBlobSupportWithoutCaching(idb) {\n    return new Promise$1(function (resolve) {\n        var txn = idb.transaction(DETECT_BLOB_SUPPORT_STORE, READ_WRITE);\n        var blob = createBlob(['']);\n        txn.objectStore(DETECT_BLOB_SUPPORT_STORE).put(blob, 'key');\n\n        txn.onabort = function (e) {\n            // If the transaction aborts now its due to not being able to\n            // write to the database, likely due to the disk being full\n            e.preventDefault();\n            e.stopPropagation();\n            resolve(false);\n        };\n\n        txn.oncomplete = function () {\n            var matchedChrome = navigator.userAgent.match(/Chrome\\/(\\d+)/);\n            var matchedEdge = navigator.userAgent.match(/Edge\\//);\n            // MS Edge pretends to be Chrome 42:\n            // https://msdn.microsoft.com/en-us/library/hh869301%28v=vs.85%29.aspx\n            resolve(matchedEdge || !matchedChrome || parseInt(matchedChrome[1], 10) >= 43);\n        };\n    })[\"catch\"](function () {\n        return false; // error, so assume unsupported\n    });\n}\n\nfunction _checkBlobSupport(idb) {\n    if (typeof supportsBlobs === 'boolean') {\n        return Promise$1.resolve(supportsBlobs);\n    }\n    return _checkBlobSupportWithoutCaching(idb).then(function (value) {\n        supportsBlobs = value;\n        return supportsBlobs;\n    });\n}\n\nfunction _deferReadiness(dbInfo) {\n    var dbContext = dbContexts[dbInfo.name];\n\n    // Create a deferred object representing the current database operation.\n    var deferredOperation = {};\n\n    deferredOperation.promise = new Promise$1(function (resolve, reject) {\n        deferredOperation.resolve = resolve;\n        deferredOperation.reject = reject;\n    });\n\n    // Enqueue the deferred operation.\n    dbContext.deferredOperations.push(deferredOperation);\n\n    // Chain its promise to the database readiness.\n    if (!dbContext.dbReady) {\n        dbContext.dbReady = deferredOperation.promise;\n    } else {\n        dbContext.dbReady = dbContext.dbReady.then(function () {\n            return deferredOperation.promise;\n        });\n    }\n}\n\nfunction _advanceReadiness(dbInfo) {\n    var dbContext = dbContexts[dbInfo.name];\n\n    // Dequeue a deferred operation.\n    var deferredOperation = dbContext.deferredOperations.pop();\n\n    // Resolve its promise (which is part of the database readiness\n    // chain of promises).\n    if (deferredOperation) {\n        deferredOperation.resolve();\n        return deferredOperation.promise;\n    }\n}\n\nfunction _rejectReadiness(dbInfo, err) {\n    var dbContext = dbContexts[dbInfo.name];\n\n    // Dequeue a deferred operation.\n    var deferredOperation = dbContext.deferredOperations.pop();\n\n    // Reject its promise (which is part of the database readiness\n    // chain of promises).\n    if (deferredOperation) {\n        deferredOperation.reject(err);\n        return deferredOperation.promise;\n    }\n}\n\nfunction _getConnection(dbInfo, upgradeNeeded) {\n    return new Promise$1(function (resolve, reject) {\n        dbContexts[dbInfo.name] = dbContexts[dbInfo.name] || createDbContext();\n\n        if (dbInfo.db) {\n            if (upgradeNeeded) {\n                _deferReadiness(dbInfo);\n                dbInfo.db.close();\n            } else {\n                return resolve(dbInfo.db);\n            }\n        }\n\n        var dbArgs = [dbInfo.name];\n\n        if (upgradeNeeded) {\n            dbArgs.push(dbInfo.version);\n        }\n\n        var openreq = idb.open.apply(idb, dbArgs);\n\n        if (upgradeNeeded) {\n            openreq.onupgradeneeded = function (e) {\n                var db = openreq.result;\n                try {\n                    db.createObjectStore(dbInfo.storeName);\n                    if (e.oldVersion <= 1) {\n                        // Added when support for blob shims was added\n                        db.createObjectStore(DETECT_BLOB_SUPPORT_STORE);\n                    }\n                } catch (ex) {\n                    if (ex.name === 'ConstraintError') {\n                        console.warn('The database \"' + dbInfo.name + '\"' + ' has been upgraded from version ' + e.oldVersion + ' to version ' + e.newVersion + ', but the storage \"' + dbInfo.storeName + '\" already exists.');\n                    } else {\n                        throw ex;\n                    }\n                }\n            };\n        }\n\n        openreq.onerror = function (e) {\n            e.preventDefault();\n            reject(openreq.error);\n        };\n\n        openreq.onsuccess = function () {\n            resolve(openreq.result);\n            _advanceReadiness(dbInfo);\n        };\n    });\n}\n\nfunction _getOriginalConnection(dbInfo) {\n    return _getConnection(dbInfo, false);\n}\n\nfunction _getUpgradedConnection(dbInfo) {\n    return _getConnection(dbInfo, true);\n}\n\nfunction _isUpgradeNeeded(dbInfo, defaultVersion) {\n    if (!dbInfo.db) {\n        return true;\n    }\n\n    var isNewStore = !dbInfo.db.objectStoreNames.contains(dbInfo.storeName);\n    var isDowngrade = dbInfo.version < dbInfo.db.version;\n    var isUpgrade = dbInfo.version > dbInfo.db.version;\n\n    if (isDowngrade) {\n        // If the version is not the default one\n        // then warn for impossible downgrade.\n        if (dbInfo.version !== defaultVersion) {\n            console.warn('The database \"' + dbInfo.name + '\"' + \" can't be downgraded from version \" + dbInfo.db.version + ' to version ' + dbInfo.version + '.');\n        }\n        // Align the versions to prevent errors.\n        dbInfo.version = dbInfo.db.version;\n    }\n\n    if (isUpgrade || isNewStore) {\n        // If the store is new then increment the version (if needed).\n        // This will trigger an \"upgradeneeded\" event which is required\n        // for creating a store.\n        if (isNewStore) {\n            var incVersion = dbInfo.db.version + 1;\n            if (incVersion > dbInfo.version) {\n                dbInfo.version = incVersion;\n            }\n        }\n\n        return true;\n    }\n\n    return false;\n}\n\n// encode a blob for indexeddb engines that don't support blobs\nfunction _encodeBlob(blob) {\n    return new Promise$1(function (resolve, reject) {\n        var reader = new FileReader();\n        reader.onerror = reject;\n        reader.onloadend = function (e) {\n            var base64 = btoa(e.target.result || '');\n            resolve({\n                __local_forage_encoded_blob: true,\n                data: base64,\n                type: blob.type\n            });\n        };\n        reader.readAsBinaryString(blob);\n    });\n}\n\n// decode an encoded blob\nfunction _decodeBlob(encodedBlob) {\n    var arrayBuff = _binStringToArrayBuffer(atob(encodedBlob.data));\n    return createBlob([arrayBuff], { type: encodedBlob.type });\n}\n\n// is this one of our fancy encoded blobs?\nfunction _isEncodedBlob(value) {\n    return value && value.__local_forage_encoded_blob;\n}\n\n// Specialize the default `ready()` function by making it dependent\n// on the current database operations. Thus, the driver will be actually\n// ready when it's been initialized (default) *and* there are no pending\n// operations on the database (initiated by some other instances).\nfunction _fullyReady(callback) {\n    var self = this;\n\n    var promise = self._initReady().then(function () {\n        var dbContext = dbContexts[self._dbInfo.name];\n\n        if (dbContext && dbContext.dbReady) {\n            return dbContext.dbReady;\n        }\n    });\n\n    executeTwoCallbacks(promise, callback, callback);\n    return promise;\n}\n\n// Try to establish a new db connection to replace the\n// current one which is broken (i.e. experiencing\n// InvalidStateError while creating a transaction).\nfunction _tryReconnect(dbInfo) {\n    _deferReadiness(dbInfo);\n\n    var dbContext = dbContexts[dbInfo.name];\n    var forages = dbContext.forages;\n\n    for (var i = 0; i < forages.length; i++) {\n        var forage = forages[i];\n        if (forage._dbInfo.db) {\n            forage._dbInfo.db.close();\n            forage._dbInfo.db = null;\n        }\n    }\n    dbInfo.db = null;\n\n    return _getOriginalConnection(dbInfo).then(function (db) {\n        dbInfo.db = db;\n        if (_isUpgradeNeeded(dbInfo)) {\n            // Reopen the database for upgrading.\n            return _getUpgradedConnection(dbInfo);\n        }\n        return db;\n    }).then(function (db) {\n        // store the latest db reference\n        // in case the db was upgraded\n        dbInfo.db = dbContext.db = db;\n        for (var i = 0; i < forages.length; i++) {\n            forages[i]._dbInfo.db = db;\n        }\n    })[\"catch\"](function (err) {\n        _rejectReadiness(dbInfo, err);\n        throw err;\n    });\n}\n\n// FF doesn't like Promises (micro-tasks) and IDDB store operations,\n// so we have to do it with callbacks\nfunction createTransaction(dbInfo, mode, callback, retries) {\n    if (retries === undefined) {\n        retries = 1;\n    }\n\n    try {\n        var tx = dbInfo.db.transaction(dbInfo.storeName, mode);\n        callback(null, tx);\n    } catch (err) {\n        if (retries > 0 && (!dbInfo.db || err.name === 'InvalidStateError' || err.name === 'NotFoundError')) {\n            return Promise$1.resolve().then(function () {\n                if (!dbInfo.db || err.name === 'NotFoundError' && !dbInfo.db.objectStoreNames.contains(dbInfo.storeName) && dbInfo.version <= dbInfo.db.version) {\n                    // increase the db version, to create the new ObjectStore\n                    if (dbInfo.db) {\n                        dbInfo.version = dbInfo.db.version + 1;\n                    }\n                    // Reopen the database for upgrading.\n                    return _getUpgradedConnection(dbInfo);\n                }\n            }).then(function () {\n                return _tryReconnect(dbInfo).then(function () {\n                    createTransaction(dbInfo, mode, callback, retries - 1);\n                });\n            })[\"catch\"](callback);\n        }\n\n        callback(err);\n    }\n}\n\nfunction createDbContext() {\n    return {\n        // Running localForages sharing a database.\n        forages: [],\n        // Shared database.\n        db: null,\n        // Database readiness (promise).\n        dbReady: null,\n        // Deferred operations on the database.\n        deferredOperations: []\n    };\n}\n\n// Open the IndexedDB database (automatically creates one if one didn't\n// previously exist), using any options set in the config.\nfunction _initStorage(options) {\n    var self = this;\n    var dbInfo = {\n        db: null\n    };\n\n    if (options) {\n        for (var i in options) {\n            dbInfo[i] = options[i];\n        }\n    }\n\n    // Get the current context of the database;\n    var dbContext = dbContexts[dbInfo.name];\n\n    // ...or create a new context.\n    if (!dbContext) {\n        dbContext = createDbContext();\n        // Register the new context in the global container.\n        dbContexts[dbInfo.name] = dbContext;\n    }\n\n    // Register itself as a running localForage in the current context.\n    dbContext.forages.push(self);\n\n    // Replace the default `ready()` function with the specialized one.\n    if (!self._initReady) {\n        self._initReady = self.ready;\n        self.ready = _fullyReady;\n    }\n\n    // Create an array of initialization states of the related localForages.\n    var initPromises = [];\n\n    function ignoreErrors() {\n        // Don't handle errors here,\n        // just makes sure related localForages aren't pending.\n        return Promise$1.resolve();\n    }\n\n    for (var j = 0; j < dbContext.forages.length; j++) {\n        var forage = dbContext.forages[j];\n        if (forage !== self) {\n            // Don't wait for itself...\n            initPromises.push(forage._initReady()[\"catch\"](ignoreErrors));\n        }\n    }\n\n    // Take a snapshot of the related localForages.\n    var forages = dbContext.forages.slice(0);\n\n    // Initialize the connection process only when\n    // all the related localForages aren't pending.\n    return Promise$1.all(initPromises).then(function () {\n        dbInfo.db = dbContext.db;\n        // Get the connection or open a new one without upgrade.\n        return _getOriginalConnection(dbInfo);\n    }).then(function (db) {\n        dbInfo.db = db;\n        if (_isUpgradeNeeded(dbInfo, self._defaultConfig.version)) {\n            // Reopen the database for upgrading.\n            return _getUpgradedConnection(dbInfo);\n        }\n        return db;\n    }).then(function (db) {\n        dbInfo.db = dbContext.db = db;\n        self._dbInfo = dbInfo;\n        // Share the final connection amongst related localForages.\n        for (var k = 0; k < forages.length; k++) {\n            var forage = forages[k];\n            if (forage !== self) {\n                // Self is already up-to-date.\n                forage._dbInfo.db = dbInfo.db;\n                forage._dbInfo.version = dbInfo.version;\n            }\n        }\n    });\n}\n\nfunction getItem(key, callback) {\n    var self = this;\n\n    key = normalizeKey(key);\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {\n                if (err) {\n                    return reject(err);\n                }\n\n                try {\n                    var store = transaction.objectStore(self._dbInfo.storeName);\n                    var req = store.get(key);\n\n                    req.onsuccess = function () {\n                        var value = req.result;\n                        if (value === undefined) {\n                            value = null;\n                        }\n                        if (_isEncodedBlob(value)) {\n                            value = _decodeBlob(value);\n                        }\n                        resolve(value);\n                    };\n\n                    req.onerror = function () {\n                        reject(req.error);\n                    };\n                } catch (e) {\n                    reject(e);\n                }\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Iterate over all items stored in database.\nfunction iterate(iterator, callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {\n                if (err) {\n                    return reject(err);\n                }\n\n                try {\n                    var store = transaction.objectStore(self._dbInfo.storeName);\n                    var req = store.openCursor();\n                    var iterationNumber = 1;\n\n                    req.onsuccess = function () {\n                        var cursor = req.result;\n\n                        if (cursor) {\n                            var value = cursor.value;\n                            if (_isEncodedBlob(value)) {\n                                value = _decodeBlob(value);\n                            }\n                            var result = iterator(value, cursor.key, iterationNumber++);\n\n                            // when the iterator callback returns any\n                            // (non-`undefined`) value, then we stop\n                            // the iteration immediately\n                            if (result !== void 0) {\n                                resolve(result);\n                            } else {\n                                cursor[\"continue\"]();\n                            }\n                        } else {\n                            resolve();\n                        }\n                    };\n\n                    req.onerror = function () {\n                        reject(req.error);\n                    };\n                } catch (e) {\n                    reject(e);\n                }\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n\n    return promise;\n}\n\nfunction setItem(key, value, callback) {\n    var self = this;\n\n    key = normalizeKey(key);\n\n    var promise = new Promise$1(function (resolve, reject) {\n        var dbInfo;\n        self.ready().then(function () {\n            dbInfo = self._dbInfo;\n            if (toString.call(value) === '[object Blob]') {\n                return _checkBlobSupport(dbInfo.db).then(function (blobSupport) {\n                    if (blobSupport) {\n                        return value;\n                    }\n                    return _encodeBlob(value);\n                });\n            }\n            return value;\n        }).then(function (value) {\n            createTransaction(self._dbInfo, READ_WRITE, function (err, transaction) {\n                if (err) {\n                    return reject(err);\n                }\n\n                try {\n                    var store = transaction.objectStore(self._dbInfo.storeName);\n\n                    // The reason we don't _save_ null is because IE 10 does\n                    // not support saving the `null` type in IndexedDB. How\n                    // ironic, given the bug below!\n                    // See: https://github.com/mozilla/localForage/issues/161\n                    if (value === null) {\n                        value = undefined;\n                    }\n\n                    var req = store.put(value, key);\n\n                    transaction.oncomplete = function () {\n                        // Cast to undefined so the value passed to\n                        // callback/promise is the same as what one would get out\n                        // of `getItem()` later. This leads to some weirdness\n                        // (setItem('foo', undefined) will return `null`), but\n                        // it's not my fault localStorage is our baseline and that\n                        // it's weird.\n                        if (value === undefined) {\n                            value = null;\n                        }\n\n                        resolve(value);\n                    };\n                    transaction.onabort = transaction.onerror = function () {\n                        var err = req.error ? req.error : req.transaction.error;\n                        reject(err);\n                    };\n                } catch (e) {\n                    reject(e);\n                }\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction removeItem(key, callback) {\n    var self = this;\n\n    key = normalizeKey(key);\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            createTransaction(self._dbInfo, READ_WRITE, function (err, transaction) {\n                if (err) {\n                    return reject(err);\n                }\n\n                try {\n                    var store = transaction.objectStore(self._dbInfo.storeName);\n                    // We use a Grunt task to make this safe for IE and some\n                    // versions of Android (including those used by Cordova).\n                    // Normally IE won't like `.delete()` and will insist on\n                    // using `['delete']()`, but we have a build step that\n                    // fixes this for us now.\n                    var req = store[\"delete\"](key);\n                    transaction.oncomplete = function () {\n                        resolve();\n                    };\n\n                    transaction.onerror = function () {\n                        reject(req.error);\n                    };\n\n                    // The request will be also be aborted if we've exceeded our storage\n                    // space.\n                    transaction.onabort = function () {\n                        var err = req.error ? req.error : req.transaction.error;\n                        reject(err);\n                    };\n                } catch (e) {\n                    reject(e);\n                }\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction clear(callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            createTransaction(self._dbInfo, READ_WRITE, function (err, transaction) {\n                if (err) {\n                    return reject(err);\n                }\n\n                try {\n                    var store = transaction.objectStore(self._dbInfo.storeName);\n                    var req = store.clear();\n\n                    transaction.oncomplete = function () {\n                        resolve();\n                    };\n\n                    transaction.onabort = transaction.onerror = function () {\n                        var err = req.error ? req.error : req.transaction.error;\n                        reject(err);\n                    };\n                } catch (e) {\n                    reject(e);\n                }\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction length(callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {\n                if (err) {\n                    return reject(err);\n                }\n\n                try {\n                    var store = transaction.objectStore(self._dbInfo.storeName);\n                    var req = store.count();\n\n                    req.onsuccess = function () {\n                        resolve(req.result);\n                    };\n\n                    req.onerror = function () {\n                        reject(req.error);\n                    };\n                } catch (e) {\n                    reject(e);\n                }\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction key(n, callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        if (n < 0) {\n            resolve(null);\n\n            return;\n        }\n\n        self.ready().then(function () {\n            createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {\n                if (err) {\n                    return reject(err);\n                }\n\n                try {\n                    var store = transaction.objectStore(self._dbInfo.storeName);\n                    var advanced = false;\n                    var req = store.openKeyCursor();\n\n                    req.onsuccess = function () {\n                        var cursor = req.result;\n                        if (!cursor) {\n                            // this means there weren't enough keys\n                            resolve(null);\n\n                            return;\n                        }\n\n                        if (n === 0) {\n                            // We have the first key, return it if that's what they\n                            // wanted.\n                            resolve(cursor.key);\n                        } else {\n                            if (!advanced) {\n                                // Otherwise, ask the cursor to skip ahead n\n                                // records.\n                                advanced = true;\n                                cursor.advance(n);\n                            } else {\n                                // When we get here, we've got the nth key.\n                                resolve(cursor.key);\n                            }\n                        }\n                    };\n\n                    req.onerror = function () {\n                        reject(req.error);\n                    };\n                } catch (e) {\n                    reject(e);\n                }\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction keys(callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {\n                if (err) {\n                    return reject(err);\n                }\n\n                try {\n                    var store = transaction.objectStore(self._dbInfo.storeName);\n                    var req = store.openKeyCursor();\n                    var keys = [];\n\n                    req.onsuccess = function () {\n                        var cursor = req.result;\n\n                        if (!cursor) {\n                            resolve(keys);\n                            return;\n                        }\n\n                        keys.push(cursor.key);\n                        cursor[\"continue\"]();\n                    };\n\n                    req.onerror = function () {\n                        reject(req.error);\n                    };\n                } catch (e) {\n                    reject(e);\n                }\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction dropInstance(options, callback) {\n    callback = getCallback.apply(this, arguments);\n\n    var currentConfig = this.config();\n    options = typeof options !== 'function' && options || {};\n    if (!options.name) {\n        options.name = options.name || currentConfig.name;\n        options.storeName = options.storeName || currentConfig.storeName;\n    }\n\n    var self = this;\n    var promise;\n    if (!options.name) {\n        promise = Promise$1.reject('Invalid arguments');\n    } else {\n        var isCurrentDb = options.name === currentConfig.name && self._dbInfo.db;\n\n        var dbPromise = isCurrentDb ? Promise$1.resolve(self._dbInfo.db) : _getOriginalConnection(options).then(function (db) {\n            var dbContext = dbContexts[options.name];\n            var forages = dbContext.forages;\n            dbContext.db = db;\n            for (var i = 0; i < forages.length; i++) {\n                forages[i]._dbInfo.db = db;\n            }\n            return db;\n        });\n\n        if (!options.storeName) {\n            promise = dbPromise.then(function (db) {\n                _deferReadiness(options);\n\n                var dbContext = dbContexts[options.name];\n                var forages = dbContext.forages;\n\n                db.close();\n                for (var i = 0; i < forages.length; i++) {\n                    var forage = forages[i];\n                    forage._dbInfo.db = null;\n                }\n\n                var dropDBPromise = new Promise$1(function (resolve, reject) {\n                    var req = idb.deleteDatabase(options.name);\n\n                    req.onerror = req.onblocked = function (err) {\n                        var db = req.result;\n                        if (db) {\n                            db.close();\n                        }\n                        reject(err);\n                    };\n\n                    req.onsuccess = function () {\n                        var db = req.result;\n                        if (db) {\n                            db.close();\n                        }\n                        resolve(db);\n                    };\n                });\n\n                return dropDBPromise.then(function (db) {\n                    dbContext.db = db;\n                    for (var i = 0; i < forages.length; i++) {\n                        var _forage = forages[i];\n                        _advanceReadiness(_forage._dbInfo);\n                    }\n                })[\"catch\"](function (err) {\n                    (_rejectReadiness(options, err) || Promise$1.resolve())[\"catch\"](function () {});\n                    throw err;\n                });\n            });\n        } else {\n            promise = dbPromise.then(function (db) {\n                if (!db.objectStoreNames.contains(options.storeName)) {\n                    return;\n                }\n\n                var newVersion = db.version + 1;\n\n                _deferReadiness(options);\n\n                var dbContext = dbContexts[options.name];\n                var forages = dbContext.forages;\n\n                db.close();\n                for (var i = 0; i < forages.length; i++) {\n                    var forage = forages[i];\n                    forage._dbInfo.db = null;\n                    forage._dbInfo.version = newVersion;\n                }\n\n                var dropObjectPromise = new Promise$1(function (resolve, reject) {\n                    var req = idb.open(options.name, newVersion);\n\n                    req.onerror = function (err) {\n                        var db = req.result;\n                        db.close();\n                        reject(err);\n                    };\n\n                    req.onupgradeneeded = function () {\n                        var db = req.result;\n                        db.deleteObjectStore(options.storeName);\n                    };\n\n                    req.onsuccess = function () {\n                        var db = req.result;\n                        db.close();\n                        resolve(db);\n                    };\n                });\n\n                return dropObjectPromise.then(function (db) {\n                    dbContext.db = db;\n                    for (var j = 0; j < forages.length; j++) {\n                        var _forage2 = forages[j];\n                        _forage2._dbInfo.db = db;\n                        _advanceReadiness(_forage2._dbInfo);\n                    }\n                })[\"catch\"](function (err) {\n                    (_rejectReadiness(options, err) || Promise$1.resolve())[\"catch\"](function () {});\n                    throw err;\n                });\n            });\n        }\n    }\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nvar asyncStorage = {\n    _driver: 'asyncStorage',\n    _initStorage: _initStorage,\n    _support: isIndexedDBValid(),\n    iterate: iterate,\n    getItem: getItem,\n    setItem: setItem,\n    removeItem: removeItem,\n    clear: clear,\n    length: length,\n    key: key,\n    keys: keys,\n    dropInstance: dropInstance\n};\n\nfunction isWebSQLValid() {\n    return typeof openDatabase === 'function';\n}\n\n// Sadly, the best way to save binary data in WebSQL/localStorage is serializing\n// it to Base64, so this is how we store it to prevent very strange errors with less\n// verbose ways of binary <-> string data storage.\nvar BASE_CHARS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\nvar BLOB_TYPE_PREFIX = '~~local_forage_type~';\nvar BLOB_TYPE_PREFIX_REGEX = /^~~local_forage_type~([^~]+)~/;\n\nvar SERIALIZED_MARKER = '__lfsc__:';\nvar SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER.length;\n\n// OMG the serializations!\nvar TYPE_ARRAYBUFFER = 'arbf';\nvar TYPE_BLOB = 'blob';\nvar TYPE_INT8ARRAY = 'si08';\nvar TYPE_UINT8ARRAY = 'ui08';\nvar TYPE_UINT8CLAMPEDARRAY = 'uic8';\nvar TYPE_INT16ARRAY = 'si16';\nvar TYPE_INT32ARRAY = 'si32';\nvar TYPE_UINT16ARRAY = 'ur16';\nvar TYPE_UINT32ARRAY = 'ui32';\nvar TYPE_FLOAT32ARRAY = 'fl32';\nvar TYPE_FLOAT64ARRAY = 'fl64';\nvar TYPE_SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER_LENGTH + TYPE_ARRAYBUFFER.length;\n\nvar toString$1 = Object.prototype.toString;\n\nfunction stringToBuffer(serializedString) {\n    // Fill the string into a ArrayBuffer.\n    var bufferLength = serializedString.length * 0.75;\n    var len = serializedString.length;\n    var i;\n    var p = 0;\n    var encoded1, encoded2, encoded3, encoded4;\n\n    if (serializedString[serializedString.length - 1] === '=') {\n        bufferLength--;\n        if (serializedString[serializedString.length - 2] === '=') {\n            bufferLength--;\n        }\n    }\n\n    var buffer = new ArrayBuffer(bufferLength);\n    var bytes = new Uint8Array(buffer);\n\n    for (i = 0; i < len; i += 4) {\n        encoded1 = BASE_CHARS.indexOf(serializedString[i]);\n        encoded2 = BASE_CHARS.indexOf(serializedString[i + 1]);\n        encoded3 = BASE_CHARS.indexOf(serializedString[i + 2]);\n        encoded4 = BASE_CHARS.indexOf(serializedString[i + 3]);\n\n        /*jslint bitwise: true */\n        bytes[p++] = encoded1 << 2 | encoded2 >> 4;\n        bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;\n        bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;\n    }\n    return buffer;\n}\n\n// Converts a buffer to a string to store, serialized, in the backend\n// storage library.\nfunction bufferToString(buffer) {\n    // base64-arraybuffer\n    var bytes = new Uint8Array(buffer);\n    var base64String = '';\n    var i;\n\n    for (i = 0; i < bytes.length; i += 3) {\n        /*jslint bitwise: true */\n        base64String += BASE_CHARS[bytes[i] >> 2];\n        base64String += BASE_CHARS[(bytes[i] & 3) << 4 | bytes[i + 1] >> 4];\n        base64String += BASE_CHARS[(bytes[i + 1] & 15) << 2 | bytes[i + 2] >> 6];\n        base64String += BASE_CHARS[bytes[i + 2] & 63];\n    }\n\n    if (bytes.length % 3 === 2) {\n        base64String = base64String.substring(0, base64String.length - 1) + '=';\n    } else if (bytes.length % 3 === 1) {\n        base64String = base64String.substring(0, base64String.length - 2) + '==';\n    }\n\n    return base64String;\n}\n\n// Serialize a value, afterwards executing a callback (which usually\n// instructs the `setItem()` callback/promise to be executed). This is how\n// we store binary data with localStorage.\nfunction serialize(value, callback) {\n    var valueType = '';\n    if (value) {\n        valueType = toString$1.call(value);\n    }\n\n    // Cannot use `value instanceof ArrayBuffer` or such here, as these\n    // checks fail when running the tests using casper.js...\n    //\n    // TODO: See why those tests fail and use a better solution.\n    if (value && (valueType === '[object ArrayBuffer]' || value.buffer && toString$1.call(value.buffer) === '[object ArrayBuffer]')) {\n        // Convert binary arrays to a string and prefix the string with\n        // a special marker.\n        var buffer;\n        var marker = SERIALIZED_MARKER;\n\n        if (value instanceof ArrayBuffer) {\n            buffer = value;\n            marker += TYPE_ARRAYBUFFER;\n        } else {\n            buffer = value.buffer;\n\n            if (valueType === '[object Int8Array]') {\n                marker += TYPE_INT8ARRAY;\n            } else if (valueType === '[object Uint8Array]') {\n                marker += TYPE_UINT8ARRAY;\n            } else if (valueType === '[object Uint8ClampedArray]') {\n                marker += TYPE_UINT8CLAMPEDARRAY;\n            } else if (valueType === '[object Int16Array]') {\n                marker += TYPE_INT16ARRAY;\n            } else if (valueType === '[object Uint16Array]') {\n                marker += TYPE_UINT16ARRAY;\n            } else if (valueType === '[object Int32Array]') {\n                marker += TYPE_INT32ARRAY;\n            } else if (valueType === '[object Uint32Array]') {\n                marker += TYPE_UINT32ARRAY;\n            } else if (valueType === '[object Float32Array]') {\n                marker += TYPE_FLOAT32ARRAY;\n            } else if (valueType === '[object Float64Array]') {\n                marker += TYPE_FLOAT64ARRAY;\n            } else {\n                callback(new Error('Failed to get type for BinaryArray'));\n            }\n        }\n\n        callback(marker + bufferToString(buffer));\n    } else if (valueType === '[object Blob]') {\n        // Conver the blob to a binaryArray and then to a string.\n        var fileReader = new FileReader();\n\n        fileReader.onload = function () {\n            // Backwards-compatible prefix for the blob type.\n            var str = BLOB_TYPE_PREFIX + value.type + '~' + bufferToString(this.result);\n\n            callback(SERIALIZED_MARKER + TYPE_BLOB + str);\n        };\n\n        fileReader.readAsArrayBuffer(value);\n    } else {\n        try {\n            callback(JSON.stringify(value));\n        } catch (e) {\n            console.error(\"Couldn't convert value into a JSON string: \", value);\n\n            callback(null, e);\n        }\n    }\n}\n\n// Deserialize data we've inserted into a value column/field. We place\n// special markers into our strings to mark them as encoded; this isn't\n// as nice as a meta field, but it's the only sane thing we can do whilst\n// keeping localStorage support intact.\n//\n// Oftentimes this will just deserialize JSON content, but if we have a\n// special marker (SERIALIZED_MARKER, defined above), we will extract\n// some kind of arraybuffer/binary data/typed array out of the string.\nfunction deserialize(value) {\n    // If we haven't marked this string as being specially serialized (i.e.\n    // something other than serialized JSON), we can just return it and be\n    // done with it.\n    if (value.substring(0, SERIALIZED_MARKER_LENGTH) !== SERIALIZED_MARKER) {\n        return JSON.parse(value);\n    }\n\n    // The following code deals with deserializing some kind of Blob or\n    // TypedArray. First we separate out the type of data we're dealing\n    // with from the data itself.\n    var serializedString = value.substring(TYPE_SERIALIZED_MARKER_LENGTH);\n    var type = value.substring(SERIALIZED_MARKER_LENGTH, TYPE_SERIALIZED_MARKER_LENGTH);\n\n    var blobType;\n    // Backwards-compatible blob type serialization strategy.\n    // DBs created with older versions of localForage will simply not have the blob type.\n    if (type === TYPE_BLOB && BLOB_TYPE_PREFIX_REGEX.test(serializedString)) {\n        var matcher = serializedString.match(BLOB_TYPE_PREFIX_REGEX);\n        blobType = matcher[1];\n        serializedString = serializedString.substring(matcher[0].length);\n    }\n    var buffer = stringToBuffer(serializedString);\n\n    // Return the right type based on the code/type set during\n    // serialization.\n    switch (type) {\n        case TYPE_ARRAYBUFFER:\n            return buffer;\n        case TYPE_BLOB:\n            return createBlob([buffer], { type: blobType });\n        case TYPE_INT8ARRAY:\n            return new Int8Array(buffer);\n        case TYPE_UINT8ARRAY:\n            return new Uint8Array(buffer);\n        case TYPE_UINT8CLAMPEDARRAY:\n            return new Uint8ClampedArray(buffer);\n        case TYPE_INT16ARRAY:\n            return new Int16Array(buffer);\n        case TYPE_UINT16ARRAY:\n            return new Uint16Array(buffer);\n        case TYPE_INT32ARRAY:\n            return new Int32Array(buffer);\n        case TYPE_UINT32ARRAY:\n            return new Uint32Array(buffer);\n        case TYPE_FLOAT32ARRAY:\n            return new Float32Array(buffer);\n        case TYPE_FLOAT64ARRAY:\n            return new Float64Array(buffer);\n        default:\n            throw new Error('Unkown type: ' + type);\n    }\n}\n\nvar localforageSerializer = {\n    serialize: serialize,\n    deserialize: deserialize,\n    stringToBuffer: stringToBuffer,\n    bufferToString: bufferToString\n};\n\n/*\n * Includes code from:\n *\n * base64-arraybuffer\n * https://github.com/niklasvh/base64-arraybuffer\n *\n * Copyright (c) 2012 Niklas von Hertzen\n * Licensed under the MIT license.\n */\n\nfunction createDbTable(t, dbInfo, callback, errorCallback) {\n    t.executeSql('CREATE TABLE IF NOT EXISTS ' + dbInfo.storeName + ' ' + '(id INTEGER PRIMARY KEY, key unique, value)', [], callback, errorCallback);\n}\n\n// Open the WebSQL database (automatically creates one if one didn't\n// previously exist), using any options set in the config.\nfunction _initStorage$1(options) {\n    var self = this;\n    var dbInfo = {\n        db: null\n    };\n\n    if (options) {\n        for (var i in options) {\n            dbInfo[i] = typeof options[i] !== 'string' ? options[i].toString() : options[i];\n        }\n    }\n\n    var dbInfoPromise = new Promise$1(function (resolve, reject) {\n        // Open the database; the openDatabase API will automatically\n        // create it for us if it doesn't exist.\n        try {\n            dbInfo.db = openDatabase(dbInfo.name, String(dbInfo.version), dbInfo.description, dbInfo.size);\n        } catch (e) {\n            return reject(e);\n        }\n\n        // Create our key/value table if it doesn't exist.\n        dbInfo.db.transaction(function (t) {\n            createDbTable(t, dbInfo, function () {\n                self._dbInfo = dbInfo;\n                resolve();\n            }, function (t, error) {\n                reject(error);\n            });\n        }, reject);\n    });\n\n    dbInfo.serializer = localforageSerializer;\n    return dbInfoPromise;\n}\n\nfunction tryExecuteSql(t, dbInfo, sqlStatement, args, callback, errorCallback) {\n    t.executeSql(sqlStatement, args, callback, function (t, error) {\n        if (error.code === error.SYNTAX_ERR) {\n            t.executeSql('SELECT name FROM sqlite_master ' + \"WHERE type='table' AND name = ?\", [dbInfo.storeName], function (t, results) {\n                if (!results.rows.length) {\n                    // if the table is missing (was deleted)\n                    // re-create it table and retry\n                    createDbTable(t, dbInfo, function () {\n                        t.executeSql(sqlStatement, args, callback, errorCallback);\n                    }, errorCallback);\n                } else {\n                    errorCallback(t, error);\n                }\n            }, errorCallback);\n        } else {\n            errorCallback(t, error);\n        }\n    }, errorCallback);\n}\n\nfunction getItem$1(key, callback) {\n    var self = this;\n\n    key = normalizeKey(key);\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            dbInfo.db.transaction(function (t) {\n                tryExecuteSql(t, dbInfo, 'SELECT * FROM ' + dbInfo.storeName + ' WHERE key = ? LIMIT 1', [key], function (t, results) {\n                    var result = results.rows.length ? results.rows.item(0).value : null;\n\n                    // Check to see if this is serialized content we need to\n                    // unpack.\n                    if (result) {\n                        result = dbInfo.serializer.deserialize(result);\n                    }\n\n                    resolve(result);\n                }, function (t, error) {\n                    reject(error);\n                });\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction iterate$1(iterator, callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n\n            dbInfo.db.transaction(function (t) {\n                tryExecuteSql(t, dbInfo, 'SELECT * FROM ' + dbInfo.storeName, [], function (t, results) {\n                    var rows = results.rows;\n                    var length = rows.length;\n\n                    for (var i = 0; i < length; i++) {\n                        var item = rows.item(i);\n                        var result = item.value;\n\n                        // Check to see if this is serialized content\n                        // we need to unpack.\n                        if (result) {\n                            result = dbInfo.serializer.deserialize(result);\n                        }\n\n                        result = iterator(result, item.key, i + 1);\n\n                        // void(0) prevents problems with redefinition\n                        // of `undefined`.\n                        if (result !== void 0) {\n                            resolve(result);\n                            return;\n                        }\n                    }\n\n                    resolve();\n                }, function (t, error) {\n                    reject(error);\n                });\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction _setItem(key, value, callback, retriesLeft) {\n    var self = this;\n\n    key = normalizeKey(key);\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            // The localStorage API doesn't return undefined values in an\n            // \"expected\" way, so undefined is always cast to null in all\n            // drivers. See: https://github.com/mozilla/localForage/pull/42\n            if (value === undefined) {\n                value = null;\n            }\n\n            // Save the original value to pass to the callback.\n            var originalValue = value;\n\n            var dbInfo = self._dbInfo;\n            dbInfo.serializer.serialize(value, function (value, error) {\n                if (error) {\n                    reject(error);\n                } else {\n                    dbInfo.db.transaction(function (t) {\n                        tryExecuteSql(t, dbInfo, 'INSERT OR REPLACE INTO ' + dbInfo.storeName + ' ' + '(key, value) VALUES (?, ?)', [key, value], function () {\n                            resolve(originalValue);\n                        }, function (t, error) {\n                            reject(error);\n                        });\n                    }, function (sqlError) {\n                        // The transaction failed; check\n                        // to see if it's a quota error.\n                        if (sqlError.code === sqlError.QUOTA_ERR) {\n                            // We reject the callback outright for now, but\n                            // it's worth trying to re-run the transaction.\n                            // Even if the user accepts the prompt to use\n                            // more storage on Safari, this error will\n                            // be called.\n                            //\n                            // Try to re-run the transaction.\n                            if (retriesLeft > 0) {\n                                resolve(_setItem.apply(self, [key, originalValue, callback, retriesLeft - 1]));\n                                return;\n                            }\n                            reject(sqlError);\n                        }\n                    });\n                }\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction setItem$1(key, value, callback) {\n    return _setItem.apply(this, [key, value, callback, 1]);\n}\n\nfunction removeItem$1(key, callback) {\n    var self = this;\n\n    key = normalizeKey(key);\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            dbInfo.db.transaction(function (t) {\n                tryExecuteSql(t, dbInfo, 'DELETE FROM ' + dbInfo.storeName + ' WHERE key = ?', [key], function () {\n                    resolve();\n                }, function (t, error) {\n                    reject(error);\n                });\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Deletes every item in the table.\n// TODO: Find out if this resets the AUTO_INCREMENT number.\nfunction clear$1(callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            dbInfo.db.transaction(function (t) {\n                tryExecuteSql(t, dbInfo, 'DELETE FROM ' + dbInfo.storeName, [], function () {\n                    resolve();\n                }, function (t, error) {\n                    reject(error);\n                });\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Does a simple `COUNT(key)` to get the number of items stored in\n// localForage.\nfunction length$1(callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            dbInfo.db.transaction(function (t) {\n                // Ahhh, SQL makes this one soooooo easy.\n                tryExecuteSql(t, dbInfo, 'SELECT COUNT(key) as c FROM ' + dbInfo.storeName, [], function (t, results) {\n                    var result = results.rows.item(0).c;\n                    resolve(result);\n                }, function (t, error) {\n                    reject(error);\n                });\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Return the key located at key index X; essentially gets the key from a\n// `WHERE id = ?`. This is the most efficient way I can think to implement\n// this rarely-used (in my experience) part of the API, but it can seem\n// inconsistent, because we do `INSERT OR REPLACE INTO` on `setItem()`, so\n// the ID of each key will change every time it's updated. Perhaps a stored\n// procedure for the `setItem()` SQL would solve this problem?\n// TODO: Don't change ID on `setItem()`.\nfunction key$1(n, callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            dbInfo.db.transaction(function (t) {\n                tryExecuteSql(t, dbInfo, 'SELECT key FROM ' + dbInfo.storeName + ' WHERE id = ? LIMIT 1', [n + 1], function (t, results) {\n                    var result = results.rows.length ? results.rows.item(0).key : null;\n                    resolve(result);\n                }, function (t, error) {\n                    reject(error);\n                });\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction keys$1(callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            dbInfo.db.transaction(function (t) {\n                tryExecuteSql(t, dbInfo, 'SELECT key FROM ' + dbInfo.storeName, [], function (t, results) {\n                    var keys = [];\n\n                    for (var i = 0; i < results.rows.length; i++) {\n                        keys.push(results.rows.item(i).key);\n                    }\n\n                    resolve(keys);\n                }, function (t, error) {\n                    reject(error);\n                });\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// https://www.w3.org/TR/webdatabase/#databases\n// > There is no way to enumerate or delete the databases available for an origin from this API.\nfunction getAllStoreNames(db) {\n    return new Promise$1(function (resolve, reject) {\n        db.transaction(function (t) {\n            t.executeSql('SELECT name FROM sqlite_master ' + \"WHERE type='table' AND name <> '__WebKitDatabaseInfoTable__'\", [], function (t, results) {\n                var storeNames = [];\n\n                for (var i = 0; i < results.rows.length; i++) {\n                    storeNames.push(results.rows.item(i).name);\n                }\n\n                resolve({\n                    db: db,\n                    storeNames: storeNames\n                });\n            }, function (t, error) {\n                reject(error);\n            });\n        }, function (sqlError) {\n            reject(sqlError);\n        });\n    });\n}\n\nfunction dropInstance$1(options, callback) {\n    callback = getCallback.apply(this, arguments);\n\n    var currentConfig = this.config();\n    options = typeof options !== 'function' && options || {};\n    if (!options.name) {\n        options.name = options.name || currentConfig.name;\n        options.storeName = options.storeName || currentConfig.storeName;\n    }\n\n    var self = this;\n    var promise;\n    if (!options.name) {\n        promise = Promise$1.reject('Invalid arguments');\n    } else {\n        promise = new Promise$1(function (resolve) {\n            var db;\n            if (options.name === currentConfig.name) {\n                // use the db reference of the current instance\n                db = self._dbInfo.db;\n            } else {\n                db = openDatabase(options.name, '', '', 0);\n            }\n\n            if (!options.storeName) {\n                // drop all database tables\n                resolve(getAllStoreNames(db));\n            } else {\n                resolve({\n                    db: db,\n                    storeNames: [options.storeName]\n                });\n            }\n        }).then(function (operationInfo) {\n            return new Promise$1(function (resolve, reject) {\n                operationInfo.db.transaction(function (t) {\n                    function dropTable(storeName) {\n                        return new Promise$1(function (resolve, reject) {\n                            t.executeSql('DROP TABLE IF EXISTS ' + storeName, [], function () {\n                                resolve();\n                            }, function (t, error) {\n                                reject(error);\n                            });\n                        });\n                    }\n\n                    var operations = [];\n                    for (var i = 0, len = operationInfo.storeNames.length; i < len; i++) {\n                        operations.push(dropTable(operationInfo.storeNames[i]));\n                    }\n\n                    Promise$1.all(operations).then(function () {\n                        resolve();\n                    })[\"catch\"](function (e) {\n                        reject(e);\n                    });\n                }, function (sqlError) {\n                    reject(sqlError);\n                });\n            });\n        });\n    }\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nvar webSQLStorage = {\n    _driver: 'webSQLStorage',\n    _initStorage: _initStorage$1,\n    _support: isWebSQLValid(),\n    iterate: iterate$1,\n    getItem: getItem$1,\n    setItem: setItem$1,\n    removeItem: removeItem$1,\n    clear: clear$1,\n    length: length$1,\n    key: key$1,\n    keys: keys$1,\n    dropInstance: dropInstance$1\n};\n\nfunction isLocalStorageValid() {\n    try {\n        return typeof localStorage !== 'undefined' && 'setItem' in localStorage &&\n        // in IE8 typeof localStorage.setItem === 'object'\n        !!localStorage.setItem;\n    } catch (e) {\n        return false;\n    }\n}\n\nfunction _getKeyPrefix(options, defaultConfig) {\n    var keyPrefix = options.name + '/';\n\n    if (options.storeName !== defaultConfig.storeName) {\n        keyPrefix += options.storeName + '/';\n    }\n    return keyPrefix;\n}\n\n// Check if localStorage throws when saving an item\nfunction checkIfLocalStorageThrows() {\n    var localStorageTestKey = '_localforage_support_test';\n\n    try {\n        localStorage.setItem(localStorageTestKey, true);\n        localStorage.removeItem(localStorageTestKey);\n\n        return false;\n    } catch (e) {\n        return true;\n    }\n}\n\n// Check if localStorage is usable and allows to save an item\n// This method checks if localStorage is usable in Safari Private Browsing\n// mode, or in any other case where the available quota for localStorage\n// is 0 and there wasn't any saved items yet.\nfunction _isLocalStorageUsable() {\n    return !checkIfLocalStorageThrows() || localStorage.length > 0;\n}\n\n// Config the localStorage backend, using options set in the config.\nfunction _initStorage$2(options) {\n    var self = this;\n    var dbInfo = {};\n    if (options) {\n        for (var i in options) {\n            dbInfo[i] = options[i];\n        }\n    }\n\n    dbInfo.keyPrefix = _getKeyPrefix(options, self._defaultConfig);\n\n    if (!_isLocalStorageUsable()) {\n        return Promise$1.reject();\n    }\n\n    self._dbInfo = dbInfo;\n    dbInfo.serializer = localforageSerializer;\n\n    return Promise$1.resolve();\n}\n\n// Remove all keys from the datastore, effectively destroying all data in\n// the app's key/value store!\nfunction clear$2(callback) {\n    var self = this;\n    var promise = self.ready().then(function () {\n        var keyPrefix = self._dbInfo.keyPrefix;\n\n        for (var i = localStorage.length - 1; i >= 0; i--) {\n            var key = localStorage.key(i);\n\n            if (key.indexOf(keyPrefix) === 0) {\n                localStorage.removeItem(key);\n            }\n        }\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Retrieve an item from the store. Unlike the original async_storage\n// library in Gaia, we don't modify return values at all. If a key's value\n// is `undefined`, we pass that value to the callback function.\nfunction getItem$2(key, callback) {\n    var self = this;\n\n    key = normalizeKey(key);\n\n    var promise = self.ready().then(function () {\n        var dbInfo = self._dbInfo;\n        var result = localStorage.getItem(dbInfo.keyPrefix + key);\n\n        // If a result was found, parse it from the serialized\n        // string into a JS object. If result isn't truthy, the key\n        // is likely undefined and we'll pass it straight to the\n        // callback.\n        if (result) {\n            result = dbInfo.serializer.deserialize(result);\n        }\n\n        return result;\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Iterate over all items in the store.\nfunction iterate$2(iterator, callback) {\n    var self = this;\n\n    var promise = self.ready().then(function () {\n        var dbInfo = self._dbInfo;\n        var keyPrefix = dbInfo.keyPrefix;\n        var keyPrefixLength = keyPrefix.length;\n        var length = localStorage.length;\n\n        // We use a dedicated iterator instead of the `i` variable below\n        // so other keys we fetch in localStorage aren't counted in\n        // the `iterationNumber` argument passed to the `iterate()`\n        // callback.\n        //\n        // See: github.com/mozilla/localForage/pull/435#discussion_r38061530\n        var iterationNumber = 1;\n\n        for (var i = 0; i < length; i++) {\n            var key = localStorage.key(i);\n            if (key.indexOf(keyPrefix) !== 0) {\n                continue;\n            }\n            var value = localStorage.getItem(key);\n\n            // If a result was found, parse it from the serialized\n            // string into a JS object. If result isn't truthy, the\n            // key is likely undefined and we'll pass it straight\n            // to the iterator.\n            if (value) {\n                value = dbInfo.serializer.deserialize(value);\n            }\n\n            value = iterator(value, key.substring(keyPrefixLength), iterationNumber++);\n\n            if (value !== void 0) {\n                return value;\n            }\n        }\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Same as localStorage's key() method, except takes a callback.\nfunction key$2(n, callback) {\n    var self = this;\n    var promise = self.ready().then(function () {\n        var dbInfo = self._dbInfo;\n        var result;\n        try {\n            result = localStorage.key(n);\n        } catch (error) {\n            result = null;\n        }\n\n        // Remove the prefix from the key, if a key is found.\n        if (result) {\n            result = result.substring(dbInfo.keyPrefix.length);\n        }\n\n        return result;\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction keys$2(callback) {\n    var self = this;\n    var promise = self.ready().then(function () {\n        var dbInfo = self._dbInfo;\n        var length = localStorage.length;\n        var keys = [];\n\n        for (var i = 0; i < length; i++) {\n            var itemKey = localStorage.key(i);\n            if (itemKey.indexOf(dbInfo.keyPrefix) === 0) {\n                keys.push(itemKey.substring(dbInfo.keyPrefix.length));\n            }\n        }\n\n        return keys;\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Supply the number of keys in the datastore to the callback function.\nfunction length$2(callback) {\n    var self = this;\n    var promise = self.keys().then(function (keys) {\n        return keys.length;\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Remove an item from the store, nice and simple.\nfunction removeItem$2(key, callback) {\n    var self = this;\n\n    key = normalizeKey(key);\n\n    var promise = self.ready().then(function () {\n        var dbInfo = self._dbInfo;\n        localStorage.removeItem(dbInfo.keyPrefix + key);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Set a key's value and run an optional callback once the value is set.\n// Unlike Gaia's implementation, the callback function is passed the value,\n// in case you want to operate on that value only after you're sure it\n// saved, or something like that.\nfunction setItem$2(key, value, callback) {\n    var self = this;\n\n    key = normalizeKey(key);\n\n    var promise = self.ready().then(function () {\n        // Convert undefined values to null.\n        // https://github.com/mozilla/localForage/pull/42\n        if (value === undefined) {\n            value = null;\n        }\n\n        // Save the original value to pass to the callback.\n        var originalValue = value;\n\n        return new Promise$1(function (resolve, reject) {\n            var dbInfo = self._dbInfo;\n            dbInfo.serializer.serialize(value, function (value, error) {\n                if (error) {\n                    reject(error);\n                } else {\n                    try {\n                        localStorage.setItem(dbInfo.keyPrefix + key, value);\n                        resolve(originalValue);\n                    } catch (e) {\n                        // localStorage capacity exceeded.\n                        // TODO: Make this a specific error/event.\n                        if (e.name === 'QuotaExceededError' || e.name === 'NS_ERROR_DOM_QUOTA_REACHED') {\n                            reject(e);\n                        }\n                        reject(e);\n                    }\n                }\n            });\n        });\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction dropInstance$2(options, callback) {\n    callback = getCallback.apply(this, arguments);\n\n    options = typeof options !== 'function' && options || {};\n    if (!options.name) {\n        var currentConfig = this.config();\n        options.name = options.name || currentConfig.name;\n        options.storeName = options.storeName || currentConfig.storeName;\n    }\n\n    var self = this;\n    var promise;\n    if (!options.name) {\n        promise = Promise$1.reject('Invalid arguments');\n    } else {\n        promise = new Promise$1(function (resolve) {\n            if (!options.storeName) {\n                resolve(options.name + '/');\n            } else {\n                resolve(_getKeyPrefix(options, self._defaultConfig));\n            }\n        }).then(function (keyPrefix) {\n            for (var i = localStorage.length - 1; i >= 0; i--) {\n                var key = localStorage.key(i);\n\n                if (key.indexOf(keyPrefix) === 0) {\n                    localStorage.removeItem(key);\n                }\n            }\n        });\n    }\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nvar localStorageWrapper = {\n    _driver: 'localStorageWrapper',\n    _initStorage: _initStorage$2,\n    _support: isLocalStorageValid(),\n    iterate: iterate$2,\n    getItem: getItem$2,\n    setItem: setItem$2,\n    removeItem: removeItem$2,\n    clear: clear$2,\n    length: length$2,\n    key: key$2,\n    keys: keys$2,\n    dropInstance: dropInstance$2\n};\n\nvar sameValue = function sameValue(x, y) {\n    return x === y || typeof x === 'number' && typeof y === 'number' && isNaN(x) && isNaN(y);\n};\n\nvar includes = function includes(array, searchElement) {\n    var len = array.length;\n    var i = 0;\n    while (i < len) {\n        if (sameValue(array[i], searchElement)) {\n            return true;\n        }\n        i++;\n    }\n\n    return false;\n};\n\nvar isArray = Array.isArray || function (arg) {\n    return Object.prototype.toString.call(arg) === '[object Array]';\n};\n\n// Drivers are stored here when `defineDriver()` is called.\n// They are shared across all instances of localForage.\nvar DefinedDrivers = {};\n\nvar DriverSupport = {};\n\nvar DefaultDrivers = {\n    INDEXEDDB: asyncStorage,\n    WEBSQL: webSQLStorage,\n    LOCALSTORAGE: localStorageWrapper\n};\n\nvar DefaultDriverOrder = [DefaultDrivers.INDEXEDDB._driver, DefaultDrivers.WEBSQL._driver, DefaultDrivers.LOCALSTORAGE._driver];\n\nvar OptionalDriverMethods = ['dropInstance'];\n\nvar LibraryMethods = ['clear', 'getItem', 'iterate', 'key', 'keys', 'length', 'removeItem', 'setItem'].concat(OptionalDriverMethods);\n\nvar DefaultConfig = {\n    description: '',\n    driver: DefaultDriverOrder.slice(),\n    name: 'localforage',\n    // Default DB size is _JUST UNDER_ 5MB, as it's the highest size\n    // we can use without a prompt.\n    size: 4980736,\n    storeName: 'keyvaluepairs',\n    version: 1.0\n};\n\nfunction callWhenReady(localForageInstance, libraryMethod) {\n    localForageInstance[libraryMethod] = function () {\n        var _args = arguments;\n        return localForageInstance.ready().then(function () {\n            return localForageInstance[libraryMethod].apply(localForageInstance, _args);\n        });\n    };\n}\n\nfunction extend() {\n    for (var i = 1; i < arguments.length; i++) {\n        var arg = arguments[i];\n\n        if (arg) {\n            for (var _key in arg) {\n                if (arg.hasOwnProperty(_key)) {\n                    if (isArray(arg[_key])) {\n                        arguments[0][_key] = arg[_key].slice();\n                    } else {\n                        arguments[0][_key] = arg[_key];\n                    }\n                }\n            }\n        }\n    }\n\n    return arguments[0];\n}\n\nvar LocalForage = function () {\n    function LocalForage(options) {\n        _classCallCheck(this, LocalForage);\n\n        for (var driverTypeKey in DefaultDrivers) {\n            if (DefaultDrivers.hasOwnProperty(driverTypeKey)) {\n                var driver = DefaultDrivers[driverTypeKey];\n                var driverName = driver._driver;\n                this[driverTypeKey] = driverName;\n\n                if (!DefinedDrivers[driverName]) {\n                    // we don't need to wait for the promise,\n                    // since the default drivers can be defined\n                    // in a blocking manner\n                    this.defineDriver(driver);\n                }\n            }\n        }\n\n        this._defaultConfig = extend({}, DefaultConfig);\n        this._config = extend({}, this._defaultConfig, options);\n        this._driverSet = null;\n        this._initDriver = null;\n        this._ready = false;\n        this._dbInfo = null;\n\n        this._wrapLibraryMethodsWithReady();\n        this.setDriver(this._config.driver)[\"catch\"](function () {});\n    }\n\n    // Set any config values for localForage; can be called anytime before\n    // the first API call (e.g. `getItem`, `setItem`).\n    // We loop through options so we don't overwrite existing config\n    // values.\n\n\n    LocalForage.prototype.config = function config(options) {\n        // If the options argument is an object, we use it to set values.\n        // Otherwise, we return either a specified config value or all\n        // config values.\n        if ((typeof options === 'undefined' ? 'undefined' : _typeof(options)) === 'object') {\n            // If localforage is ready and fully initialized, we can't set\n            // any new configuration values. Instead, we return an error.\n            if (this._ready) {\n                return new Error(\"Can't call config() after localforage \" + 'has been used.');\n            }\n\n            for (var i in options) {\n                if (i === 'storeName') {\n                    options[i] = options[i].replace(/\\W/g, '_');\n                }\n\n                if (i === 'version' && typeof options[i] !== 'number') {\n                    return new Error('Database version must be a number.');\n                }\n\n                this._config[i] = options[i];\n            }\n\n            // after all config options are set and\n            // the driver option is used, try setting it\n            if ('driver' in options && options.driver) {\n                return this.setDriver(this._config.driver);\n            }\n\n            return true;\n        } else if (typeof options === 'string') {\n            return this._config[options];\n        } else {\n            return this._config;\n        }\n    };\n\n    // Used to define a custom driver, shared across all instances of\n    // localForage.\n\n\n    LocalForage.prototype.defineDriver = function defineDriver(driverObject, callback, errorCallback) {\n        var promise = new Promise$1(function (resolve, reject) {\n            try {\n                var driverName = driverObject._driver;\n                var complianceError = new Error('Custom driver not compliant; see ' + 'https://mozilla.github.io/localForage/#definedriver');\n\n                // A driver name should be defined and not overlap with the\n                // library-defined, default drivers.\n                if (!driverObject._driver) {\n                    reject(complianceError);\n                    return;\n                }\n\n                var driverMethods = LibraryMethods.concat('_initStorage');\n                for (var i = 0, len = driverMethods.length; i < len; i++) {\n                    var driverMethodName = driverMethods[i];\n\n                    // when the property is there,\n                    // it should be a method even when optional\n                    var isRequired = !includes(OptionalDriverMethods, driverMethodName);\n                    if ((isRequired || driverObject[driverMethodName]) && typeof driverObject[driverMethodName] !== 'function') {\n                        reject(complianceError);\n                        return;\n                    }\n                }\n\n                var configureMissingMethods = function configureMissingMethods() {\n                    var methodNotImplementedFactory = function methodNotImplementedFactory(methodName) {\n                        return function () {\n                            var error = new Error('Method ' + methodName + ' is not implemented by the current driver');\n                            var promise = Promise$1.reject(error);\n                            executeCallback(promise, arguments[arguments.length - 1]);\n                            return promise;\n                        };\n                    };\n\n                    for (var _i = 0, _len = OptionalDriverMethods.length; _i < _len; _i++) {\n                        var optionalDriverMethod = OptionalDriverMethods[_i];\n                        if (!driverObject[optionalDriverMethod]) {\n                            driverObject[optionalDriverMethod] = methodNotImplementedFactory(optionalDriverMethod);\n                        }\n                    }\n                };\n\n                configureMissingMethods();\n\n                var setDriverSupport = function setDriverSupport(support) {\n                    if (DefinedDrivers[driverName]) {\n                        console.info('Redefining LocalForage driver: ' + driverName);\n                    }\n                    DefinedDrivers[driverName] = driverObject;\n                    DriverSupport[driverName] = support;\n                    // don't use a then, so that we can define\n                    // drivers that have simple _support methods\n                    // in a blocking manner\n                    resolve();\n                };\n\n                if ('_support' in driverObject) {\n                    if (driverObject._support && typeof driverObject._support === 'function') {\n                        driverObject._support().then(setDriverSupport, reject);\n                    } else {\n                        setDriverSupport(!!driverObject._support);\n                    }\n                } else {\n                    setDriverSupport(true);\n                }\n            } catch (e) {\n                reject(e);\n            }\n        });\n\n        executeTwoCallbacks(promise, callback, errorCallback);\n        return promise;\n    };\n\n    LocalForage.prototype.driver = function driver() {\n        return this._driver || null;\n    };\n\n    LocalForage.prototype.getDriver = function getDriver(driverName, callback, errorCallback) {\n        var getDriverPromise = DefinedDrivers[driverName] ? Promise$1.resolve(DefinedDrivers[driverName]) : Promise$1.reject(new Error('Driver not found.'));\n\n        executeTwoCallbacks(getDriverPromise, callback, errorCallback);\n        return getDriverPromise;\n    };\n\n    LocalForage.prototype.getSerializer = function getSerializer(callback) {\n        var serializerPromise = Promise$1.resolve(localforageSerializer);\n        executeTwoCallbacks(serializerPromise, callback);\n        return serializerPromise;\n    };\n\n    LocalForage.prototype.ready = function ready(callback) {\n        var self = this;\n\n        var promise = self._driverSet.then(function () {\n            if (self._ready === null) {\n                self._ready = self._initDriver();\n            }\n\n            return self._ready;\n        });\n\n        executeTwoCallbacks(promise, callback, callback);\n        return promise;\n    };\n\n    LocalForage.prototype.setDriver = function setDriver(drivers, callback, errorCallback) {\n        var self = this;\n\n        if (!isArray(drivers)) {\n            drivers = [drivers];\n        }\n\n        var supportedDrivers = this._getSupportedDrivers(drivers);\n\n        function setDriverToConfig() {\n            self._config.driver = self.driver();\n        }\n\n        function extendSelfWithDriver(driver) {\n            self._extend(driver);\n            setDriverToConfig();\n\n            self._ready = self._initStorage(self._config);\n            return self._ready;\n        }\n\n        function initDriver(supportedDrivers) {\n            return function () {\n                var currentDriverIndex = 0;\n\n                function driverPromiseLoop() {\n                    while (currentDriverIndex < supportedDrivers.length) {\n                        var driverName = supportedDrivers[currentDriverIndex];\n                        currentDriverIndex++;\n\n                        self._dbInfo = null;\n                        self._ready = null;\n\n                        return self.getDriver(driverName).then(extendSelfWithDriver)[\"catch\"](driverPromiseLoop);\n                    }\n\n                    setDriverToConfig();\n                    var error = new Error('No available storage method found.');\n                    self._driverSet = Promise$1.reject(error);\n                    return self._driverSet;\n                }\n\n                return driverPromiseLoop();\n            };\n        }\n\n        // There might be a driver initialization in progress\n        // so wait for it to finish in order to avoid a possible\n        // race condition to set _dbInfo\n        var oldDriverSetDone = this._driverSet !== null ? this._driverSet[\"catch\"](function () {\n            return Promise$1.resolve();\n        }) : Promise$1.resolve();\n\n        this._driverSet = oldDriverSetDone.then(function () {\n            var driverName = supportedDrivers[0];\n            self._dbInfo = null;\n            self._ready = null;\n\n            return self.getDriver(driverName).then(function (driver) {\n                self._driver = driver._driver;\n                setDriverToConfig();\n                self._wrapLibraryMethodsWithReady();\n                self._initDriver = initDriver(supportedDrivers);\n            });\n        })[\"catch\"](function () {\n            setDriverToConfig();\n            var error = new Error('No available storage method found.');\n            self._driverSet = Promise$1.reject(error);\n            return self._driverSet;\n        });\n\n        executeTwoCallbacks(this._driverSet, callback, errorCallback);\n        return this._driverSet;\n    };\n\n    LocalForage.prototype.supports = function supports(driverName) {\n        return !!DriverSupport[driverName];\n    };\n\n    LocalForage.prototype._extend = function _extend(libraryMethodsAndProperties) {\n        extend(this, libraryMethodsAndProperties);\n    };\n\n    LocalForage.prototype._getSupportedDrivers = function _getSupportedDrivers(drivers) {\n        var supportedDrivers = [];\n        for (var i = 0, len = drivers.length; i < len; i++) {\n            var driverName = drivers[i];\n            if (this.supports(driverName)) {\n                supportedDrivers.push(driverName);\n            }\n        }\n        return supportedDrivers;\n    };\n\n    LocalForage.prototype._wrapLibraryMethodsWithReady = function _wrapLibraryMethodsWithReady() {\n        // Add a stub for each driver API method that delays the call to the\n        // corresponding driver method until localForage is ready. These stubs\n        // will be replaced by the driver methods as soon as the driver is\n        // loaded, so there is no performance impact.\n        for (var i = 0, len = LibraryMethods.length; i < len; i++) {\n            callWhenReady(this, LibraryMethods[i]);\n        }\n    };\n\n    LocalForage.prototype.createInstance = function createInstance(options) {\n        return new LocalForage(options);\n    };\n\n    return LocalForage;\n}();\n\n// The actual localForage object that we expose as a module or via a\n// global. It's extended by pulling in one of our other libraries.\n\n\nvar localforage_js = new LocalForage();\n\nmodule.exports = localforage_js;\n\n},{\"3\":3}]},{},[4])(4)\n});\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./node_modules/localforage/dist/localforage.js?");

/***/ }),

/***/ "./node_modules/node-libs-browser/node_modules/path-browserify/index.js":
/*!******************************************************************************!*\
  !*** ./node_modules/node-libs-browser/node_modules/path-browserify/index.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(process) {// .dirname, .basename, and .extname methods are extracted from Node.js v8.11.1,\n// backported and transplited with Babel, with backwards-compat fixes\n\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// resolves . and .. elements in a path array with directory names there\n// must be no slashes, empty elements, or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\nfunction normalizeArray(parts, allowAboveRoot) {\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = parts.length - 1; i >= 0; i--) {\n    var last = parts[i];\n    if (last === '.') {\n      parts.splice(i, 1);\n    } else if (last === '..') {\n      parts.splice(i, 1);\n      up++;\n    } else if (up) {\n      parts.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (allowAboveRoot) {\n    for (; up--; up) {\n      parts.unshift('..');\n    }\n  }\n\n  return parts;\n}\n\n// path.resolve([from ...], to)\n// posix version\nexports.resolve = function() {\n  var resolvedPath = '',\n      resolvedAbsolute = false;\n\n  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n    var path = (i >= 0) ? arguments[i] : process.cwd();\n\n    // Skip empty and invalid entries\n    if (typeof path !== 'string') {\n      throw new TypeError('Arguments to path.resolve must be strings');\n    } else if (!path) {\n      continue;\n    }\n\n    resolvedPath = path + '/' + resolvedPath;\n    resolvedAbsolute = path.charAt(0) === '/';\n  }\n\n  // At this point the path should be resolved to a full absolute path, but\n  // handle relative paths to be safe (might happen when process.cwd() fails)\n\n  // Normalize the path\n  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\n    return !!p;\n  }), !resolvedAbsolute).join('/');\n\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n};\n\n// path.normalize(path)\n// posix version\nexports.normalize = function(path) {\n  var isAbsolute = exports.isAbsolute(path),\n      trailingSlash = substr(path, -1) === '/';\n\n  // Normalize the path\n  path = normalizeArray(filter(path.split('/'), function(p) {\n    return !!p;\n  }), !isAbsolute).join('/');\n\n  if (!path && !isAbsolute) {\n    path = '.';\n  }\n  if (path && trailingSlash) {\n    path += '/';\n  }\n\n  return (isAbsolute ? '/' : '') + path;\n};\n\n// posix version\nexports.isAbsolute = function(path) {\n  return path.charAt(0) === '/';\n};\n\n// posix version\nexports.join = function() {\n  var paths = Array.prototype.slice.call(arguments, 0);\n  return exports.normalize(filter(paths, function(p, index) {\n    if (typeof p !== 'string') {\n      throw new TypeError('Arguments to path.join must be strings');\n    }\n    return p;\n  }).join('/'));\n};\n\n\n// path.relative(from, to)\n// posix version\nexports.relative = function(from, to) {\n  from = exports.resolve(from).substr(1);\n  to = exports.resolve(to).substr(1);\n\n  function trim(arr) {\n    var start = 0;\n    for (; start < arr.length; start++) {\n      if (arr[start] !== '') break;\n    }\n\n    var end = arr.length - 1;\n    for (; end >= 0; end--) {\n      if (arr[end] !== '') break;\n    }\n\n    if (start > end) return [];\n    return arr.slice(start, end - start + 1);\n  }\n\n  var fromParts = trim(from.split('/'));\n  var toParts = trim(to.split('/'));\n\n  var length = Math.min(fromParts.length, toParts.length);\n  var samePartsLength = length;\n  for (var i = 0; i < length; i++) {\n    if (fromParts[i] !== toParts[i]) {\n      samePartsLength = i;\n      break;\n    }\n  }\n\n  var outputParts = [];\n  for (var i = samePartsLength; i < fromParts.length; i++) {\n    outputParts.push('..');\n  }\n\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));\n\n  return outputParts.join('/');\n};\n\nexports.sep = '/';\nexports.delimiter = ':';\n\nexports.dirname = function (path) {\n  if (typeof path !== 'string') path = path + '';\n  if (path.length === 0) return '.';\n  var code = path.charCodeAt(0);\n  var hasRoot = code === 47 /*/*/;\n  var end = -1;\n  var matchedSlash = true;\n  for (var i = path.length - 1; i >= 1; --i) {\n    code = path.charCodeAt(i);\n    if (code === 47 /*/*/) {\n        if (!matchedSlash) {\n          end = i;\n          break;\n        }\n      } else {\n      // We saw the first non-path separator\n      matchedSlash = false;\n    }\n  }\n\n  if (end === -1) return hasRoot ? '/' : '.';\n  if (hasRoot && end === 1) {\n    // return '//';\n    // Backwards-compat fix:\n    return '/';\n  }\n  return path.slice(0, end);\n};\n\nfunction basename(path) {\n  if (typeof path !== 'string') path = path + '';\n\n  var start = 0;\n  var end = -1;\n  var matchedSlash = true;\n  var i;\n\n  for (i = path.length - 1; i >= 0; --i) {\n    if (path.charCodeAt(i) === 47 /*/*/) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          start = i + 1;\n          break;\n        }\n      } else if (end === -1) {\n      // We saw the first non-path separator, mark this as the end of our\n      // path component\n      matchedSlash = false;\n      end = i + 1;\n    }\n  }\n\n  if (end === -1) return '';\n  return path.slice(start, end);\n}\n\n// Uses a mixed approach for backwards-compatibility, as ext behavior changed\n// in new Node.js versions, so only basename() above is backported here\nexports.basename = function (path, ext) {\n  var f = basename(path);\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n  return f;\n};\n\nexports.extname = function (path) {\n  if (typeof path !== 'string') path = path + '';\n  var startDot = -1;\n  var startPart = 0;\n  var end = -1;\n  var matchedSlash = true;\n  // Track the state of characters (if any) we see before our first dot and\n  // after any path separator we find\n  var preDotState = 0;\n  for (var i = path.length - 1; i >= 0; --i) {\n    var code = path.charCodeAt(i);\n    if (code === 47 /*/*/) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n    if (end === -1) {\n      // We saw the first non-path separator, mark this as the end of our\n      // extension\n      matchedSlash = false;\n      end = i + 1;\n    }\n    if (code === 46 /*.*/) {\n        // If this is our first dot, mark it as the start of our extension\n        if (startDot === -1)\n          startDot = i;\n        else if (preDotState !== 1)\n          preDotState = 1;\n    } else if (startDot !== -1) {\n      // We saw a non-dot and non-path separator before our dot, so we should\n      // have a good chance at having a non-empty extension\n      preDotState = -1;\n    }\n  }\n\n  if (startDot === -1 || end === -1 ||\n      // We saw a non-dot character immediately before the dot\n      preDotState === 0 ||\n      // The (right-most) trimmed path component is exactly '..'\n      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n    return '';\n  }\n  return path.slice(startDot, end);\n};\n\nfunction filter (xs, f) {\n    if (xs.filter) return xs.filter(f);\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        if (f(xs[i], i, xs)) res.push(xs[i]);\n    }\n    return res;\n}\n\n// String.prototype.substr - negative index don't work in IE8\nvar substr = 'ab'.substr(-1) === 'b'\n    ? function (str, start, len) { return str.substr(start, len) }\n    : function (str, start, len) {\n        if (start < 0) start = str.length + start;\n        return str.substr(start, len);\n    }\n;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:///./node_modules/node-libs-browser/node_modules/path-browserify/index.js?");

/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n//# sourceURL=webpack:///./node_modules/process/browser.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n\n//# sourceURL=webpack:///(webpack)/buildin/global.js?");

/***/ }),

/***/ "./node_modules/whatwg-fetch/fetch.js":
/*!********************************************!*\
  !*** ./node_modules/whatwg-fetch/fetch.js ***!
  \********************************************/
/*! exports provided: Headers, Request, Response, DOMException, fetch */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Headers\", function() { return Headers; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Request\", function() { return Request; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Response\", function() { return Response; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DOMException\", function() { return DOMException; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fetch\", function() { return fetch; });\nvar global =\n  (typeof globalThis !== 'undefined' && globalThis) ||\n  (typeof self !== 'undefined' && self) ||\n  (typeof global !== 'undefined' && global)\n\nvar support = {\n  searchParams: 'URLSearchParams' in global,\n  iterable: 'Symbol' in global && 'iterator' in Symbol,\n  blob:\n    'FileReader' in global &&\n    'Blob' in global &&\n    (function() {\n      try {\n        new Blob()\n        return true\n      } catch (e) {\n        return false\n      }\n    })(),\n  formData: 'FormData' in global,\n  arrayBuffer: 'ArrayBuffer' in global\n}\n\nfunction isDataView(obj) {\n  return obj && DataView.prototype.isPrototypeOf(obj)\n}\n\nif (support.arrayBuffer) {\n  var viewClasses = [\n    '[object Int8Array]',\n    '[object Uint8Array]',\n    '[object Uint8ClampedArray]',\n    '[object Int16Array]',\n    '[object Uint16Array]',\n    '[object Int32Array]',\n    '[object Uint32Array]',\n    '[object Float32Array]',\n    '[object Float64Array]'\n  ]\n\n  var isArrayBufferView =\n    ArrayBuffer.isView ||\n    function(obj) {\n      return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1\n    }\n}\n\nfunction normalizeName(name) {\n  if (typeof name !== 'string') {\n    name = String(name)\n  }\n  if (/[^a-z0-9\\-#$%&'*+.^_`|~!]/i.test(name) || name === '') {\n    throw new TypeError('Invalid character in header field name: \"' + name + '\"')\n  }\n  return name.toLowerCase()\n}\n\nfunction normalizeValue(value) {\n  if (typeof value !== 'string') {\n    value = String(value)\n  }\n  return value\n}\n\n// Build a destructive iterator for the value list\nfunction iteratorFor(items) {\n  var iterator = {\n    next: function() {\n      var value = items.shift()\n      return {done: value === undefined, value: value}\n    }\n  }\n\n  if (support.iterable) {\n    iterator[Symbol.iterator] = function() {\n      return iterator\n    }\n  }\n\n  return iterator\n}\n\nfunction Headers(headers) {\n  this.map = {}\n\n  if (headers instanceof Headers) {\n    headers.forEach(function(value, name) {\n      this.append(name, value)\n    }, this)\n  } else if (Array.isArray(headers)) {\n    headers.forEach(function(header) {\n      this.append(header[0], header[1])\n    }, this)\n  } else if (headers) {\n    Object.getOwnPropertyNames(headers).forEach(function(name) {\n      this.append(name, headers[name])\n    }, this)\n  }\n}\n\nHeaders.prototype.append = function(name, value) {\n  name = normalizeName(name)\n  value = normalizeValue(value)\n  var oldValue = this.map[name]\n  this.map[name] = oldValue ? oldValue + ', ' + value : value\n}\n\nHeaders.prototype['delete'] = function(name) {\n  delete this.map[normalizeName(name)]\n}\n\nHeaders.prototype.get = function(name) {\n  name = normalizeName(name)\n  return this.has(name) ? this.map[name] : null\n}\n\nHeaders.prototype.has = function(name) {\n  return this.map.hasOwnProperty(normalizeName(name))\n}\n\nHeaders.prototype.set = function(name, value) {\n  this.map[normalizeName(name)] = normalizeValue(value)\n}\n\nHeaders.prototype.forEach = function(callback, thisArg) {\n  for (var name in this.map) {\n    if (this.map.hasOwnProperty(name)) {\n      callback.call(thisArg, this.map[name], name, this)\n    }\n  }\n}\n\nHeaders.prototype.keys = function() {\n  var items = []\n  this.forEach(function(value, name) {\n    items.push(name)\n  })\n  return iteratorFor(items)\n}\n\nHeaders.prototype.values = function() {\n  var items = []\n  this.forEach(function(value) {\n    items.push(value)\n  })\n  return iteratorFor(items)\n}\n\nHeaders.prototype.entries = function() {\n  var items = []\n  this.forEach(function(value, name) {\n    items.push([name, value])\n  })\n  return iteratorFor(items)\n}\n\nif (support.iterable) {\n  Headers.prototype[Symbol.iterator] = Headers.prototype.entries\n}\n\nfunction consumed(body) {\n  if (body.bodyUsed) {\n    return Promise.reject(new TypeError('Already read'))\n  }\n  body.bodyUsed = true\n}\n\nfunction fileReaderReady(reader) {\n  return new Promise(function(resolve, reject) {\n    reader.onload = function() {\n      resolve(reader.result)\n    }\n    reader.onerror = function() {\n      reject(reader.error)\n    }\n  })\n}\n\nfunction readBlobAsArrayBuffer(blob) {\n  var reader = new FileReader()\n  var promise = fileReaderReady(reader)\n  reader.readAsArrayBuffer(blob)\n  return promise\n}\n\nfunction readBlobAsText(blob) {\n  var reader = new FileReader()\n  var promise = fileReaderReady(reader)\n  reader.readAsText(blob)\n  return promise\n}\n\nfunction readArrayBufferAsText(buf) {\n  var view = new Uint8Array(buf)\n  var chars = new Array(view.length)\n\n  for (var i = 0; i < view.length; i++) {\n    chars[i] = String.fromCharCode(view[i])\n  }\n  return chars.join('')\n}\n\nfunction bufferClone(buf) {\n  if (buf.slice) {\n    return buf.slice(0)\n  } else {\n    var view = new Uint8Array(buf.byteLength)\n    view.set(new Uint8Array(buf))\n    return view.buffer\n  }\n}\n\nfunction Body() {\n  this.bodyUsed = false\n\n  this._initBody = function(body) {\n    /*\n      fetch-mock wraps the Response object in an ES6 Proxy to\n      provide useful test harness features such as flush. However, on\n      ES5 browsers without fetch or Proxy support pollyfills must be used;\n      the proxy-pollyfill is unable to proxy an attribute unless it exists\n      on the object before the Proxy is created. This change ensures\n      Response.bodyUsed exists on the instance, while maintaining the\n      semantic of setting Request.bodyUsed in the constructor before\n      _initBody is called.\n    */\n    this.bodyUsed = this.bodyUsed\n    this._bodyInit = body\n    if (!body) {\n      this._bodyText = ''\n    } else if (typeof body === 'string') {\n      this._bodyText = body\n    } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {\n      this._bodyBlob = body\n    } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {\n      this._bodyFormData = body\n    } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n      this._bodyText = body.toString()\n    } else if (support.arrayBuffer && support.blob && isDataView(body)) {\n      this._bodyArrayBuffer = bufferClone(body.buffer)\n      // IE 10-11 can't handle a DataView body.\n      this._bodyInit = new Blob([this._bodyArrayBuffer])\n    } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {\n      this._bodyArrayBuffer = bufferClone(body)\n    } else {\n      this._bodyText = body = Object.prototype.toString.call(body)\n    }\n\n    if (!this.headers.get('content-type')) {\n      if (typeof body === 'string') {\n        this.headers.set('content-type', 'text/plain;charset=UTF-8')\n      } else if (this._bodyBlob && this._bodyBlob.type) {\n        this.headers.set('content-type', this._bodyBlob.type)\n      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n        this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8')\n      }\n    }\n  }\n\n  if (support.blob) {\n    this.blob = function() {\n      var rejected = consumed(this)\n      if (rejected) {\n        return rejected\n      }\n\n      if (this._bodyBlob) {\n        return Promise.resolve(this._bodyBlob)\n      } else if (this._bodyArrayBuffer) {\n        return Promise.resolve(new Blob([this._bodyArrayBuffer]))\n      } else if (this._bodyFormData) {\n        throw new Error('could not read FormData body as blob')\n      } else {\n        return Promise.resolve(new Blob([this._bodyText]))\n      }\n    }\n\n    this.arrayBuffer = function() {\n      if (this._bodyArrayBuffer) {\n        var isConsumed = consumed(this)\n        if (isConsumed) {\n          return isConsumed\n        }\n        if (ArrayBuffer.isView(this._bodyArrayBuffer)) {\n          return Promise.resolve(\n            this._bodyArrayBuffer.buffer.slice(\n              this._bodyArrayBuffer.byteOffset,\n              this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength\n            )\n          )\n        } else {\n          return Promise.resolve(this._bodyArrayBuffer)\n        }\n      } else {\n        return this.blob().then(readBlobAsArrayBuffer)\n      }\n    }\n  }\n\n  this.text = function() {\n    var rejected = consumed(this)\n    if (rejected) {\n      return rejected\n    }\n\n    if (this._bodyBlob) {\n      return readBlobAsText(this._bodyBlob)\n    } else if (this._bodyArrayBuffer) {\n      return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))\n    } else if (this._bodyFormData) {\n      throw new Error('could not read FormData body as text')\n    } else {\n      return Promise.resolve(this._bodyText)\n    }\n  }\n\n  if (support.formData) {\n    this.formData = function() {\n      return this.text().then(decode)\n    }\n  }\n\n  this.json = function() {\n    return this.text().then(JSON.parse)\n  }\n\n  return this\n}\n\n// HTTP methods whose capitalization should be normalized\nvar methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']\n\nfunction normalizeMethod(method) {\n  var upcased = method.toUpperCase()\n  return methods.indexOf(upcased) > -1 ? upcased : method\n}\n\nfunction Request(input, options) {\n  if (!(this instanceof Request)) {\n    throw new TypeError('Please use the \"new\" operator, this DOM object constructor cannot be called as a function.')\n  }\n\n  options = options || {}\n  var body = options.body\n\n  if (input instanceof Request) {\n    if (input.bodyUsed) {\n      throw new TypeError('Already read')\n    }\n    this.url = input.url\n    this.credentials = input.credentials\n    if (!options.headers) {\n      this.headers = new Headers(input.headers)\n    }\n    this.method = input.method\n    this.mode = input.mode\n    this.signal = input.signal\n    if (!body && input._bodyInit != null) {\n      body = input._bodyInit\n      input.bodyUsed = true\n    }\n  } else {\n    this.url = String(input)\n  }\n\n  this.credentials = options.credentials || this.credentials || 'same-origin'\n  if (options.headers || !this.headers) {\n    this.headers = new Headers(options.headers)\n  }\n  this.method = normalizeMethod(options.method || this.method || 'GET')\n  this.mode = options.mode || this.mode || null\n  this.signal = options.signal || this.signal\n  this.referrer = null\n\n  if ((this.method === 'GET' || this.method === 'HEAD') && body) {\n    throw new TypeError('Body not allowed for GET or HEAD requests')\n  }\n  this._initBody(body)\n\n  if (this.method === 'GET' || this.method === 'HEAD') {\n    if (options.cache === 'no-store' || options.cache === 'no-cache') {\n      // Search for a '_' parameter in the query string\n      var reParamSearch = /([?&])_=[^&]*/\n      if (reParamSearch.test(this.url)) {\n        // If it already exists then set the value with the current time\n        this.url = this.url.replace(reParamSearch, '$1_=' + new Date().getTime())\n      } else {\n        // Otherwise add a new '_' parameter to the end with the current time\n        var reQueryString = /\\?/\n        this.url += (reQueryString.test(this.url) ? '&' : '?') + '_=' + new Date().getTime()\n      }\n    }\n  }\n}\n\nRequest.prototype.clone = function() {\n  return new Request(this, {body: this._bodyInit})\n}\n\nfunction decode(body) {\n  var form = new FormData()\n  body\n    .trim()\n    .split('&')\n    .forEach(function(bytes) {\n      if (bytes) {\n        var split = bytes.split('=')\n        var name = split.shift().replace(/\\+/g, ' ')\n        var value = split.join('=').replace(/\\+/g, ' ')\n        form.append(decodeURIComponent(name), decodeURIComponent(value))\n      }\n    })\n  return form\n}\n\nfunction parseHeaders(rawHeaders) {\n  var headers = new Headers()\n  // Replace instances of \\r\\n and \\n followed by at least one space or horizontal tab with a space\n  // https://tools.ietf.org/html/rfc7230#section-3.2\n  var preProcessedHeaders = rawHeaders.replace(/\\r?\\n[\\t ]+/g, ' ')\n  // Avoiding split via regex to work around a common IE11 bug with the core-js 3.6.0 regex polyfill\n  // https://github.com/github/fetch/issues/748\n  // https://github.com/zloirock/core-js/issues/751\n  preProcessedHeaders\n    .split('\\r')\n    .map(function(header) {\n      return header.indexOf('\\n') === 0 ? header.substr(1, header.length) : header\n    })\n    .forEach(function(line) {\n      var parts = line.split(':')\n      var key = parts.shift().trim()\n      if (key) {\n        var value = parts.join(':').trim()\n        headers.append(key, value)\n      }\n    })\n  return headers\n}\n\nBody.call(Request.prototype)\n\nfunction Response(bodyInit, options) {\n  if (!(this instanceof Response)) {\n    throw new TypeError('Please use the \"new\" operator, this DOM object constructor cannot be called as a function.')\n  }\n  if (!options) {\n    options = {}\n  }\n\n  this.type = 'default'\n  this.status = options.status === undefined ? 200 : options.status\n  this.ok = this.status >= 200 && this.status < 300\n  this.statusText = options.statusText === undefined ? '' : '' + options.statusText\n  this.headers = new Headers(options.headers)\n  this.url = options.url || ''\n  this._initBody(bodyInit)\n}\n\nBody.call(Response.prototype)\n\nResponse.prototype.clone = function() {\n  return new Response(this._bodyInit, {\n    status: this.status,\n    statusText: this.statusText,\n    headers: new Headers(this.headers),\n    url: this.url\n  })\n}\n\nResponse.error = function() {\n  var response = new Response(null, {status: 0, statusText: ''})\n  response.type = 'error'\n  return response\n}\n\nvar redirectStatuses = [301, 302, 303, 307, 308]\n\nResponse.redirect = function(url, status) {\n  if (redirectStatuses.indexOf(status) === -1) {\n    throw new RangeError('Invalid status code')\n  }\n\n  return new Response(null, {status: status, headers: {location: url}})\n}\n\nvar DOMException = global.DOMException\ntry {\n  new DOMException()\n} catch (err) {\n  DOMException = function(message, name) {\n    this.message = message\n    this.name = name\n    var error = Error(message)\n    this.stack = error.stack\n  }\n  DOMException.prototype = Object.create(Error.prototype)\n  DOMException.prototype.constructor = DOMException\n}\n\nfunction fetch(input, init) {\n  return new Promise(function(resolve, reject) {\n    var request = new Request(input, init)\n\n    if (request.signal && request.signal.aborted) {\n      return reject(new DOMException('Aborted', 'AbortError'))\n    }\n\n    var xhr = new XMLHttpRequest()\n\n    function abortXhr() {\n      xhr.abort()\n    }\n\n    xhr.onload = function() {\n      var options = {\n        status: xhr.status,\n        statusText: xhr.statusText,\n        headers: parseHeaders(xhr.getAllResponseHeaders() || '')\n      }\n      options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL')\n      var body = 'response' in xhr ? xhr.response : xhr.responseText\n      setTimeout(function() {\n        resolve(new Response(body, options))\n      }, 0)\n    }\n\n    xhr.onerror = function() {\n      setTimeout(function() {\n        reject(new TypeError('Network request failed'))\n      }, 0)\n    }\n\n    xhr.ontimeout = function() {\n      setTimeout(function() {\n        reject(new TypeError('Network request failed'))\n      }, 0)\n    }\n\n    xhr.onabort = function() {\n      setTimeout(function() {\n        reject(new DOMException('Aborted', 'AbortError'))\n      }, 0)\n    }\n\n    function fixUrl(url) {\n      try {\n        return url === '' && global.location.href ? global.location.href : url\n      } catch (e) {\n        return url\n      }\n    }\n\n    xhr.open(request.method, fixUrl(request.url), true)\n\n    if (request.credentials === 'include') {\n      xhr.withCredentials = true\n    } else if (request.credentials === 'omit') {\n      xhr.withCredentials = false\n    }\n\n    if ('responseType' in xhr) {\n      if (support.blob) {\n        xhr.responseType = 'blob'\n      } else if (\n        support.arrayBuffer &&\n        request.headers.get('Content-Type') &&\n        request.headers.get('Content-Type').indexOf('application/octet-stream') !== -1\n      ) {\n        xhr.responseType = 'arraybuffer'\n      }\n    }\n\n    if (init && typeof init.headers === 'object' && !(init.headers instanceof Headers)) {\n      Object.getOwnPropertyNames(init.headers).forEach(function(name) {\n        xhr.setRequestHeader(name, normalizeValue(init.headers[name]))\n      })\n    } else {\n      request.headers.forEach(function(value, name) {\n        xhr.setRequestHeader(name, value)\n      })\n    }\n\n    if (request.signal) {\n      request.signal.addEventListener('abort', abortXhr)\n\n      xhr.onreadystatechange = function() {\n        // DONE (success or failure)\n        if (xhr.readyState === 4) {\n          request.signal.removeEventListener('abort', abortXhr)\n        }\n      }\n    }\n\n    xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)\n  })\n}\n\nfetch.polyfill = true\n\nif (!global.fetch) {\n  global.fetch = fetch\n  global.Headers = Headers\n  global.Request = Request\n  global.Response = Response\n}\n\n\n//# sourceURL=webpack:///./node_modules/whatwg-fetch/fetch.js?");

/***/ })

/******/ });