{"version":3,"sources":["webpack:///./node_modules/@onlabsorg/swan-js/lib/modules/list.js","webpack:///./node_modules/@onlabsorg/swan-js/lib/modules/text.js"],"names":["module","exports","types","list","isNumb","x","wrap","Numb","isList","List","undefined_list","Undefined","size","X","NaN","reverse","L","rlist","i","length","push","find","indexOf","rfind","lastIndexOf","head","n","slice","tail","text","isText","Text","undefined_text","to_numb","value","Number","s1","s2","lower","str","toLowerCase","upper","toUpperCase","trim","s","trim_head","trimStart","trim_tail","trimEnd","split","Tuple","normalize","join","separator","items","tuple","textTuple","imapSync","item","toString","Array","from"],"mappings":"sGAcAA,EAAOC,QAAWC,IACd,MAAMC,EAAO,GAEPC,EAASC,GAAKH,EAAMI,KAAKD,aAAcH,EAAMK,KAE7CC,EAASH,GAAKH,EAAMI,KAAKD,aAAcH,EAAMO,KAI7CC,GADiB,IAAIR,EAAMS,UAAU,QACpB,IAAIT,EAAMS,UAAU,SAkG3C,OAxFAR,EAAKS,KAAQP,IACT,MAAMQ,EAAIX,EAAMI,KAAKD,GACrB,OAAOQ,aAAaX,EAAMO,KAAOI,EAAED,KAAOE,KAa9CX,EAAKY,QAAUC,IACX,GAAIR,EAAOQ,GAAI,CACX,MAAMC,EAAQ,GACd,IAAK,IAAIC,EAAEF,EAAEG,OAAO,EAAGD,GAAG,EAAGA,IAAKD,EAAMG,KAAKJ,EAAEE,IAC/C,OAAOD,EAEP,OAAOP,GAiBfP,EAAKkB,KAAOhB,GAAKW,GAAKR,EAAOQ,GAAKA,EAAEM,QAAQjB,GAAKS,IAejDX,EAAKoB,MAAQlB,GAAKW,GAAKR,EAAOQ,GAAKA,EAAEQ,YAAYnB,GAAKS,IAgBtDX,EAAKsB,KAAOC,GAAKV,GAAKZ,EAAOsB,IAAMlB,EAAOQ,GAAKA,EAAEW,MAAM,EAAED,GAAKhB,EAgB9DP,EAAKyB,KAAOF,GAAKV,GAAKZ,EAAOsB,IAAMlB,EAAOQ,GAAKA,EAAEW,MAAMD,GAAKhB,EAGrDP,I,mBC3GXH,EAAOC,QAAUC,IACb,MAAM2B,EAAO,GAEPzB,EAASC,GAAKH,EAAMI,KAAKD,aAAcH,EAAMK,KAC7CuB,EAASzB,GAAKH,EAAMI,KAAKD,aAAcH,EAAM6B,KAI7CC,EAAiB,IAAI9B,EAAMS,UAAU,QACpB,IAAIT,EAAMS,UAAU,QAkL3C,OAtKAkB,EAAKI,QAAWC,GACLJ,EAAOI,GAASC,OAAOD,GAASpB,IAW3Ce,EAAKjB,KAAQP,IACT,MAAMQ,EAAIX,EAAMI,KAAKD,GACrB,OAAOQ,aAAaX,EAAM6B,KAAOlB,EAAED,KAAOE,KAgB9Ce,EAAKR,KAAOe,GAAMC,GAAMP,EAAOM,IAAON,EAAOO,GAAMA,EAAGf,QAAQc,GAAMtB,IAepEe,EAAKN,MAAQa,GAAMC,GAAMP,EAAOM,IAAON,EAAOO,GAAMA,EAAGb,YAAYY,GAAMtB,IAUzEe,EAAKS,MAAQC,GAAOT,EAAOS,GAAOA,EAAIC,cAAgBR,EAUtDH,EAAKY,MAAQF,GAAOT,EAAOS,GAAOA,EAAIG,cAAgBV,EAUtDH,EAAKc,KAAOC,GAAKd,EAAOc,GAAKA,EAAED,OAASX,EAUxCH,EAAKgB,UAAYD,GAAKd,EAAOc,GAAKA,EAAEE,YAAcd,EAUlDH,EAAKkB,UAAYH,GAAKd,EAAOc,GAAKA,EAAEI,UAAYhB,EAgBhDH,EAAKJ,KAAOC,GAAKkB,GAAKxC,EAAOsB,IAAMI,EAAOc,GAAKA,EAAEjB,MAAM,EAAED,GAAKM,EAiB9DH,EAAKD,KAAOF,GAAKkB,GAAKxC,EAAOsB,IAAMI,EAAOc,GAAKA,EAAEjB,MAAMD,GAAKM,EAgB5DH,EAAKoB,MAAQb,GAAMC,GAAMP,EAAOM,IAAON,EAAOO,GACtC,IAAInC,EAAMgD,SAASb,EAAGY,MAAMb,IAAKe,YACjCnB,EAYRH,EAAKuB,KAAOC,GAAa,IAAIC,KACzB,IAAKxB,EAAOuB,GAAY,OAAOrB,EAC/B,MAAMuB,EAAQ,IAAIrD,EAAMgD,SAASI,GAC3BE,EAAYD,EAAME,SAASC,GAAQA,EAAKC,YAC9C,OAAOC,MAAMC,KAAKL,GAAWJ,KAAKC,IAI/BxB","file":".wiki/js/swan_modules/text.08a72d3e.js","sourcesContent":["/**\n *  list module\n *  ============================================================================\n *\n *  This module contains functions for manipulating List items.\n *\n *  Unless specified otherwise, all the functions of this library assume that\n *  their parameter is an item (1-d tuple). If more that one item is passed\n *  to a function, only the first item will be used and the others will be\n *  ignored.\n */\n\n\n\nmodule.exports = (types) => {\n    const list = {};\n\n    const isNumb = x => types.wrap(x) instanceof types.Numb;\n    const isText = x => types.wrap(x) instanceof types.Text;\n    const isList = x => types.wrap(x) instanceof types.List;\n    const isFunc = x => types.wrap(x) instanceof types.Func;\n    const isUndefined = x => types.wrap(x) instanceof types.Undefined;\n    const undefined_text = new types.Undefined(\"Text\");\n    const undefined_list = new types.Undefined(\"List\");\n\n\n    /**\n     *  `list.size: List l -> Numb n`\n     *  ------------------------------------------------------------------------\n     *  Returns the number of items contained in a List item or `Undefined Number`\n     *  if the argument is not a List item. If the argument is a tuple, it\n     *  applies only to its first item.\n     */\n    list.size = (x) => {\n        const X = types.wrap(x);\n        return X instanceof types.List ? X.size : NaN;\n    };\n\n\n    /**\n     *  `list.reverse: List l1 -> List l2`\n     *  ------------------------------------------------------------------------\n     *  Given a list l1, returns a new list l2, containing the items of l1 in\n     *  reversed order.\n     *  If the argument is not a List item, this function returns Undefined List.\n     *  If the parameter is a tuple, this function applies only to the first\n     *  item and ignores the others.\n     */\n    list.reverse = L => {\n        if (isList(L)) {\n            const rlist = [];\n            for (let i=L.length-1; i>=0; i--) rlist.push(L[i]);\n            return rlist;\n        } else {\n            return undefined_list;\n        }\n    };\n\n\n    /**\n     *  `list.find: Item x -> List L -> Numb k`\n     *  ------------------------------------------------------------------------\n     *  Takes an item `x` as argument and returns a function `f`. If the\n     *  argument is a tuple, it applies only to its first item.\n     *\n     *  The returned function `f`:\n     *  - takes a list `L` as argument and returns the first position of `x` in\n     *    `L` or `-1` if `x` is not contained in `L`.\n     *  - returns Undefined List if the argument of `f` is not a List item\n     *  - applies only on the first item if the parameter of `f` is a tuple\n     */\n    list.find = x => L => isList(L) ? L.indexOf(x) : NaN;\n\n\n    /**\n     *  `list.rfind: Item x -> List L -> Numb k`\n     *  ------------------------------------------------------------------------\n     *  Takes an item `x` as argument and returns a function `f`.\n     *  If the argument is a tuple, it applies only to its first item.\n     *\n     *  The returned function `f`:\n     *  - takes a list `L` as argument and returns the last position of `x` in\n     *    `L` or `-1` if `x` is not contained in `L`.\n     *  - returns Undefined List if the argument of `f` is not a List item\n     *  - applies only on the first item if the parameter of `f` is a tuple\n     */\n    list.rfind = x => L => isList(L) ? L.lastIndexOf(x) : NaN;\n\n\n    /**\n     *  `list.head: Numb n -> List L -> List l`\n     *  ------------------------------------------------------------------------\n     *  Takes a number `n` as argument and returns a function `f`.\n     *  If the argument is a tuple, it applies only to its first item.\n     *\n     *  The returned function `f`:\n     *  - takes a list `L` as argument and returns the sub-list at the left-side\n     *    of the n-th item. If n is negative, the item position is computed as\n     *    relative to the end of `L`.\n     *  - returns Undefined List if the argument of `f` is not a List item\n     *  - applies only on the first item if the parameter of `f` is a tuple\n     */\n    list.head = n => L => isNumb(n) && isList(L) ? L.slice(0,n) : undefined_list;\n\n\n    /**\n     *  `list.tail: Numb n -> List L -> List l`\n     *  ------------------------------------------------------------------------\n     *  Takes a number `n` as argument and returns a function `f`.\n     *  If the argument is a tuple, it applies only to its first item.\n     *\n     *  The returned function `f`:\n     *  - takes a list `L` as argument and returns the sub-list at the\n     *    right-side of the n-th item (including the latter). If n is negative,\n     *    the item position is computed as relative to the end of `L`.\n     *  - returns Undefined List if the argument of `f` is not a List item\n     *  - applies only on the first item if the parameter of `f` is a tuple\n     */\n    list.tail = n => L => isNumb(n) && isList(L) ? L.slice(n) : undefined_list;\n\n\n    return list;\n};\n","/**\n *  text module\n *  ============================================================================\n *\n *  This module contains functions for manipulating Text items.\n *\n *  Unless specified otherwise, all the functions of this library assume that\n *  their parameter is an item (1-d tuple). If more that one item is passed\n *  to a function, only the first item will be used and the others will be\n *  ignored.\n */\n\n\n\nmodule.exports = types => {\n    const text = {};\n\n    const isNumb = x => types.wrap(x) instanceof types.Numb;\n    const isText = x => types.wrap(x) instanceof types.Text;\n    const isList = x => types.wrap(x) instanceof types.List;\n    const isFunc = x => types.wrap(x) instanceof types.Func;\n    const isUndefined = x => types.wrap(x) instanceof types.Undefined;\n    const undefined_text = new types.Undefined(\"Text\");\n    const undefined_list = new types.Undefined(\"List\");\n\n\n    /**\n     *  `text.to_numb: Text s -> Numb n`\n     *  ------------------------------------------------------------------------\n     *  Converts a string to a number. It accepts also binary (0b...), octal\n     *  (0o...) and exadecimal (0x...) string representations of numbers.\n     *\n     *  If the argument is not a valid string, this function returns Undefined Number.\n     *  If the argument is a tuple, only the first item will be considered.\n     */\n    text.to_numb = (value) => {\n        return isText(value) ? Number(value) : NaN;\n    };\n\n\n    /**\n     *  `text.size: Text s -> Numb n`\n     *  ------------------------------------------------------------------------\n     *  Returns the number of characters in a Text item or `Undefined Number`\n     *  if the argumen is not a Text item. If the argument is a tuple, it\n     *  applies only to its first item.\n     */\n    text.size = (x) => {\n        const X = types.wrap(x);\n        return X instanceof types.Text ? X.size : NaN;\n    };\n\n\n    /**\n     *  `text.find: Text s -> Text S -> Numb k`\n     *  ------------------------------------------------------------------------\n     *  Takes a string `s` as argument and returns a function `f`.\n     *  If the argument is a tuple, it applies only to its first item.\n     *\n     *  The returned function `f`:\n     *  - takes a string `S` as argument and returns the first position of `s`\n     *    in `S` or `-1` if `s` is not contained in `S`.\n     *  - returns Undefined Number if the argument of `f` is not a Text item\n     *  - applies only on the first item if the parameter of `f` is a tuple\n     */\n    text.find = s1 => s2 => isText(s1) && isText(s2) ? s2.indexOf(s1) : NaN;\n\n\n    /**\n     *  `text.rfind: Text s -> Text S -> Numb k`\n     *  ------------------------------------------------------------------------\n     *  Takes a string `s` as argument and returns a function `f`.\n     *  If the argument is a tuple, it applies only to its first item.\n     *\n     *  The returned function `f`:\n     *  - takes a string `S` as argument and returns the last position of `s`\n     *    in `S` or `-1` if `s` is not contained in `S`.\n     *  - returns Undefined Number if the argument of `f` is not a Text item\n     *  - applies only on the first item if the parameter of `f` is a tuple\n     */\n    text.rfind = s1 => s2 => isText(s1) && isText(s2) ? s2.lastIndexOf(s1) : NaN;\n\n\n    /**\n     *  `text.lower: Text S -> Text s`\n     *  ------------------------------------------------------------------------\n     *  Returns the passed string in lower-case or `Undefined Text` if the\n     *  argument is not a Text item. If the argument is a tuple, this\n     *  function applies to its first item only.\n     */\n    text.lower = str => isText(str) ? str.toLowerCase() : undefined_text;\n\n\n    /**\n     *  `text.upper: Text s -> Text S`\n     *  ------------------------------------------------------------------------\n     *  Returns the passed string in upper-case or `Undefined Text` if the\n     *  argument is not a Text item. If the argument is a tuple, this\n     *  function applies to its first item only.\n     */\n    text.upper = str => isText(str) ? str.toUpperCase() : undefined_text;\n\n\n    /**\n     *  `text.trim: Text S -> Text s`\n     *  ------------------------------------------------------------------------\n     *  Removed the leading and trailing spaces from the given string.\n     *  If the argument is not a Text item, this functions return Undefined Text.\n     *  If the parameter is a tuple, this function applies to its first item only.\n     */\n    text.trim = s => isText(s) ? s.trim() : undefined_text;\n\n\n    /**\n     *  `text.trim_head: Text S -> Text s`\n     *  ------------------------------------------------------------------------\n     *  Removed the leading spaces from the given string.\n     *  If the argument is not a Text item, this functions return Undefined Text.\n     *  If the parameter is a tuple, this function applies to its first item only.\n     */\n    text.trim_head = s => isText(s) ? s.trimStart() : undefined_text;\n\n\n    /**\n     *  `text.trim_tail: Text S -> Text s`\n     *  ------------------------------------------------------------------------\n     *  Removed the trailing spaces from the given string.\n     *  If the argument is not a Text item, this functions return Undefined Text.\n     *  If the parameter is a tuple, this function applies to its first item only.\n     */\n    text.trim_tail = s => isText(s) ? s.trimEnd() : undefined_text;\n\n\n    /**\n     *  `text.head: Numb n -> Text S -> Text s`\n     *  ------------------------------------------------------------------------\n     *  Takes a number `n` as argument and returns a function `f`.\n     *  If the argument is a tuple, it applies only to its first item.\n     *\n     *  The returned function `f`:\n     *  - takes a string `s` as argument and returns the substring at the\n     *    left-side of the n-th character. If n is negative, the character\n     *    position is computed as relative to the end of `L`.\n     *  - returns Undefined Text if the argument of `f` is not a Text item\n     *  - applies only on the first item if the parameter of `f` is a tuple\n     */\n    text.head = n => s => isNumb(n) && isText(s) ? s.slice(0,n) : undefined_text;\n\n\n    /**\n     *  `text.tail: Numb n -> Text S -> Text s`\n     *  ------------------------------------------------------------------------\n     *  Takes a number `n` as argument and returns a function `f`.\n     *  If the argument is a tuple, it applies only to its first item.\n     *\n     *  The returned function `f`:\n     *  - takes a string `s` as argument and returns the substring at the\n     *    right-side of the n-th character (including the latter). If n is\n     *    negative, the character position is computed as relative to the\n     *    end of `S`.\n     *  - returns Undefined Text if the argument of `f` is not a Text item\n     *  - applies only on the first item if the parameter of `f` is a tuple\n     */\n    text.tail = n => s => isNumb(n) && isText(s) ? s.slice(n) : undefined_text;\n\n\n    /**\n     *  `text.split: Text s -> Text S -> List l`\n     *  ------------------------------------------------------------------------\n     *  Takes a string `s` as argument and returns a function `f`.\n     *  If the argument is a tuple, it applies only to its first item.\n     *\n     *  The returned function `f`:\n     *  - takes a string `S` as argument and returns the tuple of substrings\n     *    separated by s. For example, if the divider is `s=\":\"` and the string\n     *    is `S=\"a:b:c\"`, the function `f` returns `(\"a\",\"b\",\"c\")`.\n     *  - returns Undefined Text if the argument of `f` is not a Text item\n     *  - applies only on the first item if the parameter of `f` is a tuple\n     */\n    text.split = s1 => s2 => isText(s1) && isText(s2) ?\n            new types.Tuple(...s2.split(s1)).normalize() :\n            undefined_text;\n\n    /**\n     *  `text.join: Text s -> Tuple T -> Text S`\n     *  ------------------------------------------------------------------------\n     *  Takes a separator `s` as argument and returns a function `f`.\n     *  If the argument is a tuple, it applies only to its first item.\n     *\n     *  The returned function `f` takes a Tuple `T` of Text items as\n     *  argument and returns the string obtained by joining all the items\n     *  with interposed  sparator.\n     */\n    text.join = separator => (...items) => {\n        if (!isText(separator)) return undefined_text;\n        const tuple = new types.Tuple(...items);\n        const textTuple = tuple.imapSync(item => item.toString());\n        return Array.from(textTuple).join(separator);\n    }\n\n\n    return text;\n}\n"],"sourceRoot":""}